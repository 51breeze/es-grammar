const stackKey = Symbol("stackKey");
const Colors = require('colors');
const fs = require('fs');
const path = require('path');
Colors.setTheme({
    silly: 'rainbow',
    input: 'grey',
    verbose: 'cyan',
    info: 'green',
    data: 'blue',
    help: 'cyan',
    warn: 'yellow',
    debug: 'magenta',
    error: 'red'
});

const directiveMap={
    "Runtime":true,
    "Syntax":true,
}

module.exports={
    checkDirective( name ){
        return directiveMap[name]
    },
    getStacks(){
        return this[ stackKey ] || (this[stackKey] = require('../stacks'));
    },

    readdir(pathName, isFull ){
        if( !fs.existsSync(pathName) ){
            return null;
        }
        var files = fs.readdirSync( pathName );
        files = files.filter(function(a){
            return !(a==='.' || a==='..');
        });
        if( isFull ){
            return files.map(function(name){
                return path.join(pathName,name);
            });
        }
        return files;
    },

    getStackByName( name ){
        const stacks = this.getStacks();
        return stacks[name] || null;
    },

    isStackByName(target, name, flag ){
        const fn = this.getStackByName( name );
        const result = fn && target instanceof fn;
        return result && flag ? target : result;
    },
    
    createStack(compilation,node,scope,parentNode,parentStack){
        if( !node ){
            return null;
        }
        const stacks = this.getStacks();
        switch( node.type ){
            case "Program":
                return new stacks.Program(compilation,node,scope,parentNode,parentStack);
            case "Literal" :
                return new stacks.Literal(compilation,node,scope,parentNode,parentStack);
            case "TemplateLiteral" :
                return new stacks.TemplateLiteral(compilation,node,scope,parentNode,parentStack);
            case "TemplateElement" :
                return new stacks.TemplateElement(compilation,node,scope,parentNode,parentStack);
            case "Identifier":
                return new stacks.Identifier(compilation,node,scope,parentNode,parentStack);
            case "MethodDefinition":
                if( node.kind === "get"){
                    return new stacks.MethodGetterDefinition(compilation,node,scope,parentNode,parentStack);
                }else if( node.kind === "set"){
                    return new stacks.MethodSetterDefinition(compilation,node,scope,parentNode,parentStack);
                }
                return new stacks.MethodDefinition(compilation,node,scope,parentNode,parentStack);
            case "PropertyDefinition":
                return new stacks.PropertyDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeDefinition":
                return new stacks.TypeDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeTupleDefinition":
                return new stacks.TypeTupleDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeTupleUnionDefinition":
                return new stacks.TypeTupleUnionDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeTupleRestDefinition":
                return new stacks.TypeTupleRestDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeUnionDefinition":
                return new stacks.TypeUnionDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeGenericDefinition":
                return new stacks.TypeGenericDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeFunctionDefinition":
                return new stacks.TypeFunctionDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeObjectDefinition":
                return new stacks.TypeObjectDefinition(compilation,node,scope,parentNode,parentStack);
            case "TypeObjectPropertyDefinition":
                return new stacks.TypeObjectPropertyDefinition(compilation,node,scope,parentNode,parentStack);    
            case "GenericTypeAssignmentDeclaration":
                return new stacks.GenericTypeAssignmentDeclaration(compilation,node,scope,parentNode,parentStack);
            case "GenericTypeDeclaration":
                return new stacks.GenericTypeDeclaration(compilation,node,scope,parentNode,parentStack);
            case "GenericDeclaration":
                return new stacks.GenericDeclaration(compilation,node,scope,parentNode,parentStack);
            case "PackageDeclaration":
                return new stacks.PackageDeclaration(compilation,node,scope,parentNode,parentStack);
            case "DeclaratorDeclaration":
                return new stacks.DeclaratorDeclaration(compilation,node,scope,parentNode,parentStack);
            case "DeclaratorVariable":
                return new stacks.DeclaratorVariable(compilation,node,scope,parentNode,parentStack);
            case "DeclaratorFunction":
                return new stacks.DeclaratorFunction(compilation,node,scope,parentNode,parentStack);
            case "DeclaratorTypeAlias":
                return new stacks.DeclaratorTypeAlias(compilation,node,scope,parentNode,parentStack);
            case "ClassDeclaration":
                return new stacks.ClassDeclaration(compilation,node,scope,parentNode,parentStack);
            case "InterfaceDeclaration":
                return new stacks.InterfaceDeclaration(compilation,node,scope,parentNode,parentStack);
            case "EnumProperty":
                return new stacks.EnumProperty(compilation,node,scope,parentNode,parentStack);
            case "EnumDeclaration":
                return new stacks.EnumDeclaration(compilation,node,scope,parentNode,parentStack);
            case "FunctionDeclaration":
                return new stacks.FunctionDeclaration(compilation,node,scope,parentNode,parentStack);
            case "VariableDeclaration":
                return new stacks.VariableDeclaration(compilation,node,scope,parentNode,parentStack);
            case "VariableDeclarator":
                return new stacks.VariableDeclarator(compilation,node,scope,parentNode,parentStack);
            case "ModifierDeclaration":
                return new stacks.ModifierDeclaration(compilation,node,scope,parentNode,parentStack);
            case "AnnotationDeclaration":
                return new stacks.AnnotationDeclaration(compilation,node,scope,parentNode,parentStack);
            case "AnnotationExpression":
                return new stacks.AnnotationExpression(compilation,node,scope,parentNode,parentStack);
            case "MetatypeDeclaration":
                return new stacks.MetatypeDeclaration(compilation,node,scope,parentNode,parentStack);
            case "RestElement":
                return new stacks.RestElement(compilation,node,scope,parentNode,parentStack);
            case "SpreadElement":
                return new stacks.SpreadElement(compilation,node,scope,parentNode,parentStack);
            case "ReturnStatement":
                return new stacks.ReturnStatement(compilation,node,scope,parentNode,parentStack);
            case "ExpressionStatement":
                return new stacks.ExpressionStatement(compilation,node,scope,parentNode,parentStack);
            case "ParenthesizedExpression":
                return new stacks.ParenthesizedExpression(compilation,node,scope,parentNode,parentStack);
            case "BlockStatement":
                return new stacks.BlockStatement(compilation,node,scope,parentNode,parentStack);
            case "IfStatement":
                return new stacks.IfStatement(compilation,node,scope,parentNode,parentStack);
            case "WhileStatement":
                return new stacks.WhileStatement(compilation,node,scope,parentNode,parentStack);
            case "DoWhileStatement":
                return new stacks.DoWhileStatement(compilation,node,scope,parentNode,parentStack);
            case "SwitchStatement":
                return new stacks.SwitchStatement(compilation,node,scope,parentNode,parentStack);
            case "SwitchCase":
                return new stacks.SwitchCase(compilation,node,scope,parentNode,parentStack);
            case "BreakStatement":
                return new stacks.BreakStatement(compilation,node,scope,parentNode,parentStack);
            case "ForStatement":
                return new stacks.ForStatement(compilation,node,scope,parentNode,parentStack);
            case "ForInStatement":
                return new stacks.ForInStatement(compilation,node,scope,parentNode,parentStack);
            case "ForOfStatement":
                return new stacks.ForOfStatement(compilation,node,scope,parentNode,parentStack);
            case "TryStatement":
                return new stacks.TryStatement(compilation,node,scope,parentNode,parentStack);
            case "WhenStatement":
                return new stacks.WhenStatement(compilation,node,scope,parentNode,parentStack);
            case "MemberExpression":
                return new stacks.MemberExpression(compilation,node,scope,parentNode,parentStack);
            case "ObjectExpression":
                return new stacks.ObjectExpression(compilation,node,scope,parentNode,parentStack);
            case "ArrowFunctionExpression":
                return new stacks.ArrowFunctionExpression(compilation,node,scope,parentNode,parentStack);
            case "FunctionExpression":
                return new stacks.FunctionExpression(compilation,node,scope,parentNode,parentStack);
            case "ArrayExpression":
                return new stacks.ArrayExpression(compilation,node,scope,parentNode,parentStack);
            case "LogicalExpression":
                return new stacks.LogicalExpression(compilation,node,scope,parentNode,parentStack);
            case "ConditionalExpression":
                return new stacks.ConditionalExpression(compilation,node,scope,parentNode,parentStack);
            case "SequenceExpression":
                return new stacks.SequenceExpression(compilation,node,scope,parentNode,parentStack);
            case "AwaitExpression":
                return new stacks.AwaitExpression(compilation,node,scope,parentNode,parentStack);
            case "TypeAssertExpression":
                return new stacks.TypeAssertExpression(compilation,node,scope,parentNode,parentStack);
            case "TypeTransformExpression":
                return new stacks.TypeTransformExpression(compilation,node,scope,parentNode,parentStack);
            case "AssignmentExpression":
                return new stacks.AssignmentExpression(compilation,node,scope,parentNode,parentStack);
            case "AssignmentPattern":
                return new stacks.AssignmentPattern(compilation,node,scope,parentNode,parentStack);
            case "ThisExpression":
                return new stacks.ThisExpression(compilation,node,scope,parentNode,parentStack);
            case "Super":
                return new stacks.SuperExpression(compilation,node,scope,parentNode,parentStack);
            case "BinaryExpression":
                return new stacks.BinaryExpression(compilation,node,scope,parentNode,parentStack);
            case "CallExpression":
                return new stacks.CallExpression(compilation,node,scope,parentNode,parentStack);
            case "NewExpression":
                return new stacks.NewExpression(compilation,node,scope,parentNode,parentStack);
            case "UpdateExpression":
                return new stacks.UpdateExpression(compilation,node,scope,parentNode,parentStack);
            case "UnaryExpression":
                return new stacks.UnaryExpression(compilation,node,scope,parentNode,parentStack);
            case "ObjectPattern":
                return new stacks.ObjectPattern(compilation,node,scope,parentNode,parentStack);
            case "ArrayPattern":
                return new stacks.ArrayPattern(compilation,node,scope,parentNode,parentStack);
            case "Property":
                return new stacks.Property(compilation,node,scope,parentNode,parentStack);
            case "ImportDeclaration":
                return new stacks.ImportDeclaration(compilation,node,scope,parentNode,parentStack);
            case "ImportSpecifier":
                return new stacks.ImportSpecifier(compilation,node,scope,parentNode,parentStack);
            case "LabeledStatement":
                return new stacks.LabeledStatement(compilation,node,scope,parentNode,parentStack);
            case "ContinueStatement":
                return new stacks.ContinueStatement(compilation,node,scope,parentNode,parentStack);
            default :
                 //console.log( node )
                //throw new Error("Unrecognized token");
        }   
    },
    info( msg ){
        console.info( msg.info );
    },
    silly( msg ){
        console.log( msg.silly );
    },
    input( msg ){
        console.log( msg.input );
    },
    verbose( msg ){
        console.log( msg.verbose );
    },
    prompt( msg ){
        console.log( msg.prompt );
    },
    data( msg ){
        console.log( msg.data );
    },
    help( msg ){
        console.log( msg.help );
    },
    warn( msg ){
        console.warn( msg.warn );
    },
    debug( msg ){
        console.debug( msg.debug );
    },
    error( msg ){
        console.error( msg.error );
        //process.exit(0);
    },
    scalarMap:["number","boolean","float","int","uint","double","regexp","string"],  
    isScalar(type){
        return type && !type.isModule && !type.isInstanceofType && (type.isLiteralType || (type.isAliasType && this.scalarMap.includes( type.toString() )));
    },
    isTypeModule(type){
        return type && type.isModule && (type.isClass || type.isInterface || type.isEnum) === true;
    },
    isWrapType(type){
        return type && 
        type.isType && 
        (type.isTupleType || 
        type.isGenericType || 
        type.isGenericValueType || 
        type.isClassGenericType || 
        type.isInstanceofType || 
        type.isLiteralType || 
        type.isLiteralObjectType || 
        type.isLiteralArrayType || 
        type.isFunctionType || 
        type.isAliasType) === true;
    },
    isLiteralObjectType(type){
        return type && type.isType && (type.isTupleType || type.isLiteralObjectType || type.isLiteralArrayType) === true;
    },
    isClassType(type){
        if(type && type.isType && type.isModule && (type.isClass || type.isEnum) ){
            return true;
        }
        return false;
    },
    isLocalModule( module ){
        return module && !module.isDeclaratorModule && this.isTypeModule(module);
    },
    isGloableModule(module){
        return module && module.isDeclaratorModule && this.isTypeModule(module);
    },
    isInterface(module){
        return module.isInterface && this.isTypeModule(module);
    },
    checkTypeForBoth(left,right){
        if( left === right ){
            return true;
        }
        if( !left || !right ){
            return false;
        }
        if( right.isLiteralType ){
            right = right.extends[0];
        }
        if( left.isLiteralObjectType ){
           return left.check( right );
        }
        if( !left.isModule && left.isUnionType && left.isType ){
            if( right.isModule || !(right.isUnionType && right.isType)  || left.elements.length !== right.elements.length ){
                return false;
            }
            return left.elements.every( item=>{
                return right.elements.includes( item );
            });
        }
        if( !left.isModule && left.isTupleType && left.isType ){
            if( right.isModule || !(right.isTupleType && right.isType) || left.elements.length !== right.elements.length ){
                return false;
            }
            return left.elements.every( item=>{
                return right.elements.includes( item );
            });
        }
        return left.id === right.id && left.namesapce === right.namesapce;
    },

    isArray(type){
        return type && type.id ==="Array" && type.isDeclaratorModule && type.isModule && type.isClass;
    },
    isObject(type){
        return type && type.id ==="Object" && type.isDeclaratorModule && type.isModule && type.isClass;
    },
    isFunction( stack ){
        if(!stack || !stack.isStack )return false;
        if( stack.isCallExpression || stack.isAccessor ){
            return false;
        }
        if( stack.isProperty && stack.init ){
            stack = stack.init;
        }
        if( stack.isFunctionExpression || stack.isMethodDefinition || stack.isTypeFunctionDefinition){
            return true; 
        }
        return false;
    },
    firstToUpper(name){
        return name.substr(0,1).toUpperCase()+name.substr(1);
    },
    checkDepend(module, depModule){
        return depModule && depModule.isModule && depModule.extends.concat(depModule.implements).some( depModule=>{
            if(depModule === module)return true;
            return this.checkDepend(module,depModule);
        });
    },
    getOriginType(type){
        while( this.isWrapType(type) && type.extends && type.extends[0] ){
            type = type.extends[0];
        }
        return type;
    },
    toTypeUniqueArray( array ){
        const data = new Set();
        const items = [];
        array.forEach( value=>{
            const key = value.type().toString();
            if( !data.has(key) ){
                data.add(key);
                items.push( value )
            }
        });
        return items;
    }
}