const acorn = require("acorn");
const
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128;

 const
    BIND_NONE = 0, 
    BIND_VAR = 1, 
    BIND_LEXICAL = 2,
    BIND_FUNCTION = 3, 
    BIND_SIMPLE_CATCH = 4,
    BIND_OUTSIDE = 5;

const FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

const Parser = acorn.Parser
const TokenType = Parser.acorn.TokenType;
const tokTypes = Parser.acorn.tokTypes;
const keywordTypes = Parser.acorn.keywordTypes;

const lineBreak = /\r\n?|\n|\u2028|\u2029/;

function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

function DestructuringErrors() {
    this.shorthandAssign =
    this.trailingComma =
    this.parenthesizedAssign =
    this.parenthesizedBind =
    this.parenthesizedBindParam = 
    this.doubleProto =
      -1;
}

keywordTypes["is"] = new TokenType("is", {beforeExpr: true, binop: 7,keyword:"is"});
tokTypes._is = keywordTypes["is"];

keywordTypes["as"] = new TokenType("as", {beforeExpr: true, binop: 7,keyword:"as"});
tokTypes._as = keywordTypes["as"];

keywordTypes["package"] = new TokenType("package",{startsExpr: true,keyword:"package"});
tokTypes._package = keywordTypes["package"];

keywordTypes["implements"] = new TokenType("implements",{startsExpr: true,keyword:"implements"});
tokTypes._implements = keywordTypes["implements"];

keywordTypes["private"] = new TokenType("private",{startsExpr: true,keyword:"private"});
tokTypes._private = keywordTypes["private"];

keywordTypes["protected"] = new TokenType("protected",{startsExpr: true,keyword:"protected"});
tokTypes._protected = keywordTypes["protected"];

keywordTypes["public"] = new TokenType("public",{startsExpr: true,keyword:"public"});
tokTypes._public = keywordTypes["public"];

keywordTypes["static"] = new TokenType("static",{startsExpr: true,keyword:"static"});
tokTypes._static = keywordTypes["static"];

keywordTypes["when"] = new TokenType("when",{startsExpr: true,keyword:"when"});
tokTypes._when = keywordTypes["when"];

keywordTypes["then"] = new TokenType("then",{startsExpr: true,keyword:"then"});
tokTypes._then = keywordTypes["then"];

keywordTypes["enum"] = new TokenType("enum",{startsExpr: true,keyword:"enum"});
tokTypes._enum = keywordTypes["enum"];

keywordTypes["interface"] = new TokenType("interface",{startsExpr: true,keyword:"interface"});
tokTypes._interface = keywordTypes["interface"];

keywordTypes["abstract"] = new TokenType("abstract",{startsExpr: true,keyword:"abstract"});
tokTypes._abstract = keywordTypes["abstract"];

tokTypes._declarator = new TokenType("declarator",{startsExpr: true,keyword:"declarator"});

tokTypes._annotation = new TokenType("@",{startsExpr: true});

class SyntaxParser extends Parser {

    constructor(options, input, startPos){
        options.onComment=(block, text, start, end, startLoc, endLoc)=>{
            this.stackComments.push({
                type: block ? "Block" : "Line",
                value: text,
                start: start,
                end: end,
                startLoc,
                endLoc
            });
        };
        super(options, input, startPos);
        this.stackComments=[];
        this.keywords =  new RegExp( this.keywords.source.replace(")$","|is|package|implements|static|public|protected|private|when|then|enum|interface|abstract)$") );
        if( Array.isArray(options.reserved) && options.reserved.length > 0 ){
            this.reservedWords = new RegExp( this.reservedWords.source.replace(")$", "|"+options.reserved.join("|")+")$") );
        } 
    }

    getComments(node){
        if( this.stackComments.length < 1 )return null;
        const comments = this.stackComments.splice(0,this.stackComments.length);
        if( node ){
           node.comments = comments;
        }
        return comments;
    }

    parseDoStatement(node){
        this.getComments(node);
        return super.parseDoStatement(node)
    }
    
    parseForStatement(node){
        this.getComments(node);
        return super.parseForStatement(node)
    }
    
    parseIfStatement(node){
        this.getComments(node);
        return super.parseIfStatement(node)
    }
     
    parseThrowStatement(node){
        this.getComments(node);
        return super.parseThrowStatement(node)
    }
   
    parseTryStatement(node){
        this.getComments(node);
        return super.parseTryStatement(node)
    }
    
    parseWhileStatement(node){
        this.getComments(node);
        return super.parseWhileStatement(node)
    }
   
    parseDebuggerStatement(node){
        this.getComments(node);
        return super.parseDebuggerStatement(node);
    }

    parseBreakContinueStatement(node, keyword){
        this.getComments(node);
        return super.parseBreakContinueStatement(node,keyword);
    }

    parseSwitchStatement(node){
        this.getComments(node);
        return super.parseSwitchStatement(node);
    }

    parseReturnStatement(node){
        this.getComments(node);
        return super.parseReturnStatement(node);
    }

    parseFunction(node, statement, allowExpressionBody, isAsync){
        this.getComments(node);
        return super.parseFunction(node, statement, allowExpressionBody, isAsync);
    }

    isContextual(name) {
        if( this._isPropertyDeclarator && name==="of" ){
            return true;
        }
        return super.isContextual(name);
    };

    parseVarStatement(node, kind){
        this.getComments(node);
        return super.parseVarStatement(node, kind);
    }

    finishOp(type, size){
        if( this.__$endToken && this.__$endToken.length >0 ){
            const end = this.__$endToken[ this.__$endToken.length-1 ];
            if( type === end.token ){
                size = 1;
                type = end.value || type;
            }
        }
        return super.finishOp(type,size);
    }

    parseMaybeConditional(noIn, refDestructuringErrors){
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        if (this.eat(tokTypes.question)) {
            if( refDestructuringErrors && refDestructuringErrors.parenthesizedBindParam >= 1 ){
                refDestructuringErrors.parenthesizedBindParam = 2;
                if( this.type === tokTypes.comma || this.type === tokTypes.parenR ){
                    refDestructuringErrors.parenthesizedBindParam = 3;
                    expr.question = true;
                    return expr;
                }else if( this.type === tokTypes.colon ){
                    this.next();
                    refDestructuringErrors.parenthesizedBindParam = 3;
                    expr.question = true;
                    expr.acceptType = this.parseTypeStatement();
                    return expr;
                }
            }
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(tokTypes.colon);
            node.alternate = this.parseMaybeAssign(noIn);
            return this.finishNode(node, "ConditionalExpression")
        }
        return expr
    }
    
    parseParenAndDistinguishExpression(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
            this.next();
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            refDestructuringErrors.parenthesizedBindParam = 1;
            this.yieldPos = 0;
            this.awaitPos = 0;
            // Do not save awaitIdentPos to allow checking awaits nested in parameters
            while (this.type !== tokTypes.parenR) {
                first ? first = false : this.expect(tokTypes.comma);
                if (allowTrailingComma && this.afterTrailingComma(tokTypes.parenR, true)) {
                    lastIsComma = true;
                    break
                } else if (this.type === tokTypes.ellipsis) {
                    spreadStart = this.start;
                    exprList.push(this.parseParenItem(this.parseRestBinding()));
                    if (this.type === tokTypes.comma) { 
                        this.raise(this.start, "Comma is not permitted after the rest element");
                    }
                    break
                } else {
                    exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
                }
            }

            var innerEndPos = this.start, innerEndLoc = this.startLoc;
            this.expect(tokTypes.parenR);

            let returnType = null;
            if( canBeArrow && this.eat( tokTypes.colon ) ){
                returnType = this.parseTypeStatement();
            }

            if (canBeArrow && !this.canInsertSemicolon() && this.eat(tokTypes.arrow)) {
                this.checkPatternErrors(refDestructuringErrors, false);
                this.checkYieldAwaitInDefaultParams();
                this.yieldPos = oldYieldPos;
                this.awaitPos = oldAwaitPos;
                const node = this.parseParenArrowList(startPos, startLoc, exprList);
                node.returnType = returnType;
                return node;
            }
            if( returnType ){
                this.unexpected( returnType.start );
            }
            if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
            if (spreadStart) { this.unexpected(spreadStart); }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;

            if (exprList.length > 1) {
                val = this.startNodeAt(innerStartPos, innerStartLoc);
                val.expressions = exprList;
                this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
                val = exprList[0];
            }
        } else {
            val = this.parseParenExpression();
        }

        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        if( val.type !=="SequenceExpression" && !this.canInsertSemicolon() && (this.type === tokTypes._this || this.type === tokTypes.name ) ){
            startPos = this.start, startLoc = this.startLoc;
            par.value= this.parseSubscripts(this.parseExprAtom(), startPos, startLoc);
            val = this.finishNode(par, "TypeTransformExpression");
        }else{
            val = this.finishNode(par, "ParenthesizedExpression");
        }
        return val;
    }

    parseExprAtom(refDestructuringErrors){
        if( this.type === tokTypes._annotation ){
            return this.parseAnnotation( true );
        }
        return super.parseExprAtom(refDestructuringErrors);
    }

    parseParenItem(item){
        if( super.eat( tokTypes.colon ) ){
            item.acceptType = this.parseTypeStatement();
        }
        return item;
    }

    readToken( code ){
        //@
        if( code === 64 ){
            ++this.pos; 
            return this.finishToken(tokTypes._annotation);
        } 
        return super.readToken(code);
    }

    finishToken(type, word){
        if( word === "as" ){
            type = tokTypes._as;
        }
        return super.finishToken(type, word);
    }

    parseExpressionStatement(node, expr){
        this.getComments(node);
        return super.parseExpressionStatement(node, expr);
    }

    initFunction(node){
        if( this.type === tokTypes.star ){
            this.raise( this.lastTokStart, `Function generator unsupported`);
        }
        super.initFunction(node);
    }

    parseClassSuper(node){
        node.superClass = null;
        if( this.eat(tokTypes._extends) ){
            if( this.isStaticClass ){
                this.raise(this.lastTokStart,"Static class cannot extends super class.");
            }
            node.superClass = this.parseChainIdentifier();
            if( node.superClass ){
                node.superClass.genericity = this.getGenerics(true); 
            }
        }
        
        node.implements = null;
        if( this.eat(tokTypes._implements) ){
            if( this.isStaticClass ){
                this.raise(this.lastTokStart,"Static class cannot implements interfaces.");
            }
            node.implements = [];
            do{ 
                const imp =  this.parseChainIdentifier();
                if( imp ){
                    imp.genericity = this.getGenerics(true);
                }
                node.implements.push( imp );
            }while( this.eat(tokTypes.comma) );
        }
    }

    parseClassId(node, isStatement){
        super.parseClassId(node, isStatement);
        node.genericity = this.parseGenericType();
    }

    parseMethod(isGenerator, isAsync, allowDirectSuper){
        const generics = this.parseGenericType();
        const node = super.parseMethod(isGenerator, isAsync, allowDirectSuper);
        node.genericity = generics;
        return node;
    }

    parseFunctionParams(node){
        node.genericity = this.parseGenericType();
        super.parseFunctionParams(node);
    }

    parseBlock(createNewLexicalScope, node){
        if ( createNewLexicalScope === void 0 ){
            createNewLexicalScope = true;
        } 
        if ( node === void 0 ) {
            node = this.startNode();
        }
        const scope = this.currentScope();
        switch( scope.flags & SCOPE_FUNCTION ){
            case SCOPE_ARROW :
            case SCOPE_FUNCTION :
            case SCOPE_ASYNC :
            case SCOPE_GENERATOR :
                if( this.eat( tokTypes.colon ) ){
                   node.acceptType = this.parseTypeStatement();
                }
                break;
        }
        return super.parseBlock(createNewLexicalScope, node);
    }

    parseBindingAtom(){
        const node = super.parseBindingAtom();
        if( this.eat( tokTypes.question ) ){
            node.question = true;
        }
        if( this.eat( tokTypes.colon ) ){
            node.acceptType =  this.parseTypeStatement();
        }
        return node;
    }

    parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc){
       if( isPattern && this.eat( tokTypes.colon )  ){
           prop.acceptType = this.parseTypeStatement();
       }
       const generics = this.parseGenericType();
       super.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
       if( prop.value && prop.value.type==="FunctionExpression"){
           prop.value.genericity = generics;
       }else if( generics ){
           this.unexpected( generics.start )
       }
    }

    parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse){
        const generics = this.parseGenericType();
        const node = super.parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse);
        if( node.type==="ArrowFunctionExpression"){
            node.genericity = generics;
        }else if( generics ){
            this.unexpected( generics.start )
        }
        return node;
    }

    parseArrowExpression(node, params, isAsync){
        let type = null;
        if( this.arrowReturnType && this.arrowReturnType[ this.lastTokStart ] ){
            type = this.arrowReturnType[  this.lastTokStart ];
            delete this.arrowReturnType[ this.lastTokStart ];
        }
        const fn = super.parseArrowExpression( node, params, isAsync );
        fn.returnType = type;
        return fn;
    }

    parseFunctionBody(node, isArrowFunction, isMethod){
        if( !isArrowFunction && this.type === tokTypes.colon ){
            this.next();
            node.returnType = this.parseTypeStatement();
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod);
    }

    parseNew() {
        if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target")
            { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
          if (containsEsc)
            { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
          if (!this.inNonArrowFunction())
            { this.raiseRecoverable(node.start, "'new.target' can only be used in functions"); }
          return this.finishNode(node, "MetaProperty")
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === tokTypes._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        node.genericity = this.getGenerics(true);
        if (this.eat(tokTypes.parenL)) { node.arguments = this.parseExprList(tokTypes.parenR, this.options.ecmaVersion >= 8, false); }
        else { node.arguments = []; }
        return this.finishNode(node, "NewExpression");
    }

    parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained){
        const generics = !noCalls ? this.getGenerics(false) : null;
        const start = this.start;
        const node = super.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if( node.type==="CallExpression"){
            if(base !== node){
                node.genericity=generics;
            }else if(generics){
                this.unexpected(start);
            }
        }else if(generics){
            this.raise(start, "'(' expected.");
        }
        return node;
    }

    parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn){
        if( this.type === tokTypes._as ){
           this.next();
           const node = this.startNode();
           node.left = left;
           node.right = this.parseTypeStatement();
           return this.finishNode(node,  "TypeAssertExpression");
        }
        return  super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);;
    }

    parseStatement(context, topLevel, exports){
        switch ( this.type ){
            case tokTypes._package : 
                if( !topLevel ){
                    this.unexpected();
                }
                return this.parsePackage( this.startNode(), true );
            case tokTypes._abstract : 
                if( !topLevel ){
                    this.unexpected();
                }
                var abstract = this.startNode();
                abstract.name = "abstract";
                this.next();
                if( this.type !== tokTypes._class ){
                    this.unexpected();
                }
                this.finishNode(abstract,"ModifierDeclaration")
                var node = this.parseClass(this.startNode(), true);
                node.abstract = abstract;
                return node;
            case tokTypes._public : 
                if( !topLevel ){
                    this.unexpected();
                }
                this.next();
                var modifier = this.finishNode(this.startNode(),"ModifierDeclaration");
                modifier.name = "public";
                var node = this.parseStatement(null, topLevel, exports);
                node.modifier = modifier;
                return node;
            case tokTypes._protected : 
                if( !topLevel ){
                    this.unexpected();
                }
                this.next();
                var modifier = this.finishNode(this.startNode(),"ModifierDeclaration");
                modifier.name = "protected";
                var node = this.parseStatement(null, topLevel, exports);
                node.modifier = modifier;
                return node;
            case tokTypes._private : 
                this.raise( this.lastTokStart, `Private modifier can only be used in class member methods`);
            break;
            case tokTypes._static:
                if( !topLevel ){
                    this.unexpected();
                }
                this.next();
                var modifier = this.finishNode(this.startNode(),"ModifierDeclaration");
                modifier.name = "static";
                var node = tokTypes._class === this.type ? this.parseClass(this.startNode(), true) : this.parseStatement(null, topLevel, exports);
                node.static = modifier;
                return node;  
            case tokTypes._import:
                if( !topLevel ){
                    this.unexpected();
                }
                return this.parseImport( this.startNode() );
            case tokTypes._when:
                return this.parseWhenStatement( this.startNode() );
            case tokTypes._enum:
                return this.parseEnumStatement( this.startNode(), topLevel );
            case tokTypes._interface:
                if( !topLevel ) { this.unexpected(); }
                return this.parseInterface( this.startNode(), topLevel );
            case tokTypes._annotation:
                if( topLevel ) {
                    return this.parseAnnotation();
                }
            default:
        }
        if( topLevel && this.value ==="declare" ){
            return this.parseDeclarator( this.startNode(), topLevel );
        }
        if( this.type === tokTypes.name && this.value ==="await" && !this.inAsync){
            return this.parseAwait();
        }
        return super.parseStatement(context, topLevel, exports);
    }

    parseWhenStatement(node){
        const currentScope = this.currentScope();
        const inherit = (scope, inherit)=>{
            scope.var = scope.var.concat( inherit.var );
            scope.lexical = scope.lexical.concat( inherit.lexical );
            scope.functions = scope.functions.concat( inherit.functions );
        };

        this.next();
        node.test = this.parseParenExpression();
        this.enterScope( SCOPE_FUNCTION );
        const whenScope = this.currentScope()
        inherit( whenScope, currentScope);
        node.consequent = super.parseStatement("when");
        this.exitScope();

        this.enterScope( SCOPE_FUNCTION );
        const thenScope = this.currentScope()
        inherit(thenScope, currentScope);
        node.alternate = this.eat(tokTypes._then) ? super.parseStatement("then") : null;
        this.exitScope();

        inherit(currentScope, whenScope);
        inherit(currentScope, thenScope);
        return this.finishNode(node, "WhenStatement");
    }

    parseEnumProperty(){
        const node = this.startNode();
        node.key = this.startNode();
        if (this.type === tokTypes.name) {
            node.key.name = this.value;
            this.checkUnreserved(node.key);
            this.finishNode( node.key, "Identifier");
        } else {
            this.unexpected();
        }
        this.next();
        if( this.eat(tokTypes.eq) ){
            node.init = this.type === tokTypes.num ? this.parseLiteral(this.value) : this.parseExprAtom();
        }
        return this.finishNode(node, "EnumProperty");
    };

    parseEnumStatement(node){
        this.getComments(node);
        this.next();
        node.key = this.parseIdent(false,false)
        // if( this.type === tokTypes._extends  ){
        //     this.next();
        //     node.extends = this.parseChainIdentifier();
        // }
        this.expect( tokTypes.braceL );
        this.enterScope(1);
        const properties = [];
        while( this.type !== tokTypes.braceR ){
           if( this.type !== tokTypes.name ){
               this.unexpected();
           }
           properties.push( this.parseEnumProperty() );
           if( this.type === tokTypes.comma ){
               this.next();
           }
        }
        node.properties = properties;
        this.expect( tokTypes.braceR );
        this.semicolon();
        this.exitScope();
        return this.finishNode(node, "EnumDeclaration")
    }

    parseInterfaceMethod(element){
        const generics = this.parseGenericType();
        const node = this.startNode();
        node.genericity = generics;
        this.expect(tokTypes.parenL);
        node.params = this.parseBindingList(tokTypes.parenR, false, true);
        this.finishNode(node, "FunctionExpression")
        this.finishNode(element, "MethodDefinition");
        return node;
    }

    parseInterfaceElement(){
        if( this.eat( tokTypes.bracketL ) ){
            return this.parseMetatype();
        }
        if( this.type === tokTypes._annotation ){
            return this.parseAnnotation();
        }
        if (this.eat(tokTypes.semi)){
             return null
        }
        const parserProperty = (kind)=>{
            this.next();
            const node = this.startNode();
            node.declarations = [];
            node.kind = kind;
            const decl = this.startNode();
            decl.id = this.parseIdent();
            if (this.eat(tokTypes.eq)) {
               this.raise(this.lastTokEnd, "Interface property cannot have initialization value"); 
            }
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            this.semicolon();
            return this.finishNode(node, "VariableDeclaration");
        };

        const comments = this.getComments();
        const modifier = this.parseModifier();
        const isProperty = this.type === tokTypes._const || this.type === tokTypes._var;
        const element = isProperty ? parserProperty(this.value) : this.startNode();
        element.comments = comments;
        if( !isProperty ){
            var tryContextual = (k, noLineBreak)=>{
                if ( noLineBreak === void 0 ) noLineBreak = false;
                var start = this.start, startLoc = this.startLoc;
                if (!this.eatContextual(k)) { return false }
                if (this.type !== tokTypes.parenL && (!noLineBreak || !this.canInsertSemicolon())) { return true }
                if (element.key) { this.unexpected(); }
                element.computed = false;
                element.key = this.startNodeAt(start, startLoc);
                element.key.name = k;
                this.finishNode(element.key, "Identifier");
                return false
            };
        
            const isGenerator = this.eat(tokTypes.star);
            element.kind    = "method";
            element.isAsync = tryContextual("async", true);
            element.isGenerator = isGenerator;

            if (tryContextual("get")) {
                element.kind = "get";
            } else if (tryContextual("set")) {
                element.kind = "set";
            }

            if (!element.key){ 
                this.parsePropertyName(element);
            }
        
            var key = element.key;
            if ( key.name === "constructor" ){
                this.raise(key.start, "Interface can't have Constructor");
            } else if( key.name === "prototype" ){
                this.raise(key.start, "Interface may not have a property named prototype");
            }
            element.value = this.parseInterfaceMethod(element);
            if (element.kind === "get" && element.value.params.length !== 0)
                { this.raiseRecoverable(element.value.start, "getter should have no params"); }
            if (element.kind === "set" && element.value.params.length !== 1)
                { this.raiseRecoverable(element.value.start, "setter should have exactly one param"); }
            if (element.kind === "set" && element.value.params[0].type === "RestElement")
                { this.raiseRecoverable(element.value.params[0].start, "Setter cannot use rest params"); }

            if( this.eat( tokTypes.colon ) )
            {
                element.value.returnType = this.parseTypeStatement();
            }

        }else{
            if( element.declarations.length > 1 ){
                this.raise( element.start , `Interface member properties can only be declared one at a time.`)
            }
            if(  element.declarations[0].init ){
                this.raise( element.start , `Interface member properties cannot be have initial value.`)
            }
            this.finishNode(element, "PropertyDefinition");
        }

        if ( modifier[0] ){
            element.modifier =  modifier[0];
            if( element.modifier.name !=="public" ){
                this.raise( modifier[0].start , `Interface member can only be "public" modifier.`)
            }
        }

        if( modifier[1] ){
            this.raise( modifier[1].start, `Interface member cannot use "static" modifier `)
        }
        return element;
    }

    parseInterface(node) {
        this.getComments(node);
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, true);
        if( this.type === tokTypes._extends  ){
            this.next();
            node.extends = this.parseChainIdentifier();
            if( node.extends ){
                node.extends.genericity = this.getGenerics(true);
            }
        }
        if( this.eat(tokTypes._implements) ){
            node.implements = [];
            do{ 
                const imp = this.parseChainIdentifier();
                if( imp ){
                    imp.genericity = this.getGenerics(true);
                }
                node.implements.push( imp );
            }while( this.eat(tokTypes.comma) );
        }

        var body = [];
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        while (this.type !== tokTypes.braceR) {
          var element = this.parseInterfaceElement();
          if (element) {
            body.push(element);
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = body;
        this.exitScope();
        return this.finishNode(node,  "InterfaceDeclaration")
    }

    parseDeclarator(node){
        this.getComments(node);
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node.kind = "class";
        if( this.type === tokTypes._const || this.type === tokTypes._var ){
            const kind = this.value;
            node.expression = this.parseVarStatement(node, "var");
            node.expression.kind = kind;
            node.kind = kind;
            return this.finishNode(node,"DeclaratorVariable");
        }else if( this.type  === tokTypes._function){
            this.next();
            node.kind = "function";
            node.id = this.parseIdent();
            const generics = this.parseGenericType();
            this.expect(tokTypes.parenL);
            node.genericity = generics;
            node.params = this.parseBindingList(tokTypes.parenR, false, true);
            if( this.eat( tokTypes.colon ) ){
                node.returnType = this.parseTypeStatement();
            }
            this.semicolon();
            this.finishNode(node, "DeclaratorFunction");
            return node;
        }else if( this.type === tokTypes._class ){
            this.next();
            node.kind = "class";
        }else if( this.type === tokTypes._interface ){
            this.next();
            node.kind = "interface";
        }

        this.parseClassId(node, false);

        if( this.type === tokTypes._extends  ){
            this.next();
            const generics = this.startNode();
            node.extends = this.parseChainIdentifier();
            if( node.extends ){
                node.extends.genericity = this.getGenerics(true);
            }
        }

        if( this.eat(tokTypes._implements) ){
            node.implements = [];
            do{ 
                const imp =  this.parseChainIdentifier();
                if( imp ){
                    imp.genericity = this.getGenerics(true);
                }
                node.implements.push( imp );
            }while( this.eat(tokTypes.comma) );
        }

        if( this.type !== tokTypes.braceL && node.id && node.id.name ==="type" ){
            delete node.id;
            node.left = this.parseIdent(true);
            node.kind = "type";
            if (this.eat(tokTypes.eq)) {
                node.right = this.parseTypeStatement(false);
            } else {
                this.unexpected();
            } 
            this.semicolon();
            return this.finishNode(node,"DeclaratorTypeAlias");
        }

        var body = [];
        this.expect( tokTypes.braceL );
        this.enterScope(1);

        while (this.type !== tokTypes.braceR){
          var element = this.parseDeclaratorElement();
          if (element){
              body.push(element);
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = body;
        this.exitScope();
        return this.finishNode(node,  "DeclaratorDeclaration")
    }

    parseDeclaratorElement(){
        if( this.eat( tokTypes.bracketL ) ){
            return this.parseMetatype();
        }

        if( this.type === tokTypes._annotation ){
            return this.parseAnnotation();
        }

        if (this.eat(tokTypes.semi)){
             return null
        }

        const comments = this.getComments();
        const modifier = this.parseModifier();
        const isProperty = this.type === tokTypes._const || this.type === tokTypes._var;
        this._isPropertyDeclarator=true;
        const element = isProperty ? this.parseVarStatement( this.startNode(), this.value ) : this.startNode();
        this._isPropertyDeclarator=false;
        element.comments = comments;
        if( !isProperty ){
            var tryContextual = (k, noLineBreak)=>{
                if ( noLineBreak === void 0 ) noLineBreak = false;
                var start = this.start, startLoc = this.startLoc;
                if (!this.eatContextual(k)) { return false }
                if (this.type !== tokTypes.parenL && (!noLineBreak || !this.canInsertSemicolon())) { return true }
                if (element.key) { this.unexpected(); }
                element.computed = false;
                element.key = this.startNodeAt(start, startLoc);
                element.key.name = k;
                this.finishNode(element.key, "Identifier");
                return false
            };
        
            const isGenerator = this.eat(tokTypes.star);
            element.kind    = "method";
            element.isAsync = tryContextual("async", true);
            element.isGenerator = isGenerator;

            if (tryContextual("get")) {
                element.kind = "get";
            } else if (tryContextual("set")) {
                element.kind = "set";
            }

            if (!element.key){ 
                this.parsePropertyName(element);
            }

            var key = element.key;
            if( key.name === "prototype" ){
                this.raise(key.start, "Declarator may not have a property named prototype");
            }
            
            element.value = this.parseInterfaceMethod(element);
            if (element.kind === "get" && element.value.params.length !== 0)
                { this.raiseRecoverable(element.value.start, "getter should have no params"); }
            if (element.kind === "set" && element.value.params.length !== 1)
                { this.raiseRecoverable(element.value.start, "setter should have exactly one param"); }
            if (element.kind === "set" && element.value.params[0].type === "RestElement")
                { this.raiseRecoverable(element.value.params[0].start, "Setter cannot use rest params"); }

            if( this.eat( tokTypes.colon ) )
            {
                element.value.returnType = this.parseTypeStatement();  
            }

        }else{

            if( element.declarations.length > 1 ){
                this.raise( element.start , `Declarator member properties can only be declared one at a time.`)
            }
            this.finishNode(element, "PropertyDefinition");
        }

        if ( modifier[0] ){
            element.modifier =  modifier[0];
        }

        if ( modifier[1] ){
            element.static =  modifier[1];
        }

        return element;
    }

    parseChainIdentifier( base=null ){
        const startPos = this.start, startLoc = this.startLoc;
        const type = this.type;
        base = base || super.parseIdent( type === tokTypes._void || type ===tokTypes._class || type === tokTypes._this);
        this.checkLVal(base, BIND_NONE);
        while ( this.eat( tokTypes.dot ) ) {
            const node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            node.property = this.parseIdent( this.options.allowReserved !== "never" );
            base = this.finishNode(node,"MemberExpression");
        }
        return base;
    }

    parseGenericType(){
        if( this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60 ){
            const generics = this.startNode(); 
            const elements = [];
            this.next();
            do{
                let start = this.start, startLoc = this.startLoc;
                let left  = this.parseTypeStatement( true );
                let type  = left; 
                if( this.eat(tokTypes.eq) ){
                    type = this.startNodeAt(start,startLoc);
                    type.left = left;
                    type.right = this.parseTypeStatement();
                    this.finishNode(type,"GenericTypeAssignmentDeclaration");
                }else{
                    if( this.eat(tokTypes._extends) ){
                        left.extends = this.parseTypeStatement();
                    }
                    this.finishNode(type,"GenericTypeDeclaration");
                }
                elements.push( type );
            }while( this.eat(tokTypes.comma) );
            if( !(this.type===tokTypes.relational && this.value.charCodeAt(0) === 62) ){
                this.unexpected();
            }else{
                this.next();
            }
            generics.elements = elements;
            return this.finishNode(generics, "GenericDeclaration");
        }
        return null;
    }

    testTupleUnion(){
        const content = this.input;
        let index = this.start;
        let balancer  = 1;
        let comment = false;
        while( index < content.length ){
            const code = content.charCodeAt( index );
            if( comment === false && code === 47 && content.charCodeAt( index+1 ) === 42){
                comment = 47;
                index++;
            }else if( code === 42 && content.charCodeAt( index+1 ) === comment ){
                comment = false;
                index++;
            }else if( comment === false && code === 47 && content.charCodeAt( index+1 ) === 47 ){
                comment = 10;
                index++;
            }else if( comment === code ){
                comment = false;
            }else if( comment === false ){
                if( code===40 ){
                    balancer++;
                }else if( code===41 ){
                    balancer--;
                }
                if( code===59 || balancer===0 ){
                    break;
                }
            }
            index++;
        }
        if( balancer===0 ){
            while(index<content.length && content.charCodeAt(index+1)===32 && index++);
            return {
                arrow:content.charCodeAt( index+1 )===61 && content.charCodeAt( index+2 )===62,
                array:content.charCodeAt( index+1 )===91
            };
        }
        return null;
    }

    getGenerics( flag , node){
        if( this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60 ){
            if( !flag ){
                const content = this.input;
                let index = this.start;
                let balancer  = 0;
                let comment = false;
                while( index < content.length ){
                    const code = content.charCodeAt( index );
                    if( comment === false && code === 47 && content.charCodeAt( index+1 ) === 42){
                        comment = 47;
                        index++;
                    }else if( code === 42 && content.charCodeAt( index+1 ) === comment ){
                        comment = false;
                        index++;
                    }else if( comment === false && code === 47 && content.charCodeAt( index+1 ) === 47 ){
                        comment = 10;
                        index++;
                    }else if( comment === code ){
                        comment = false;
                    }else if( comment === false ){
                        if( code===60 ){
                            balancer++;
                        }else if( code===62 ){
                            balancer--;
                        }
                        if( code===59 || balancer===0 ){
                            break;
                        }
                    }
                    index++;
                }
                flag = balancer===0;
            }
            
            if( flag ){
                this.next();
                const generics = [];
                const endToken = this.__$endToken || (this.__$endToken = []);
                endToken.push({token:tokTypes.bitShift,value:tokTypes.relational});
                while( !(this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length===1) ){
                    const type = this.parseTypeStatement();
                    if( type.restElement ){
                        this.raise( type.start, "Rest type can only appear in tuple types");
                    }
                    generics.push( type );
                    if( !this.eat(tokTypes.comma) ){
                        break;
                    }
                }
                endToken.pop();
                if( this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length===1 ){
                    this.next();
                }else{
                    this.raise( this.start, `Expected '>'` );
                }
                if( node ){
                    node.typeElements = generics;
                    this.finishNode(node, "TypeGenericDefinition");
                }
                return generics;
            }
        }
        return null;
    }

    parseTypeStatement( prefix ){
        const start = this.start, startLoc= this.startLoc;
        let node = this.startNode();
        let typeName = "TypeDefinition";
        if( this.type  === tokTypes._void ){
            node.value = this.parseChainIdentifier();
        }else if( this.type === tokTypes.name || this.type === tokTypes._class || this.type === tokTypes._this ){
            node.value = this.parseChainIdentifier();
            const generics = this.getGenerics(true);
            if( generics ){
                node.typeElements = generics;
                typeName = "TypeGenericDefinition";
            }
            if( this.type === tokTypes.bracketL ){
                this.finishNode(node, typeName);
                return this.parseTypeStatement( node );
            }
        }else if( this.eat(tokTypes.bracketL) ){
            const elements = [];
            if( prefix ){
                node.prefix = prefix;
            }
            while( !(this.type === tokTypes.bracketR) ){
                const restElement = !!this.eat(tokTypes.ellipsis);
                const nodeType = this.parseTypeStatement();
                if( restElement ){
                    this.finishNode(nodeType,"TypeTupleRestDefinition")
                }
                elements.push( nodeType );
                if( !this.eat(tokTypes.comma) ){
                    break;
                }
            } 
            this.expect( tokTypes.bracketR );
            node.elements = elements;
            typeName = "TypeTupleDefinition";
        }
        else if( this.eat(tokTypes.braceL) ){
            var first = true;
            node.properties = [];
            const propHash = {};
            const parseProperty = ()=>{
                const prop = this.startNode();
                prop.key=this.parseIdent(this.options.allowReserved !== "never");
                if( this.eat(tokTypes.question) ) {
                    prop.key.question = true;
                }
                if( this.eat(tokTypes.colon) ) {
                    prop.value = this.parseTypeStatement();
                }
                if( propHash[prop.key.name] ){
                    this.raiseRecoverable(prop.key.start, "Redefinition of property")
                }
                propHash[prop.key.name] = true;
                return this.finishNode(prop, "TypeObjectPropertyDefinition")
            }
            while (!this.eat(tokTypes.braceR)) {
              if (!first) {
                  this.expect(tokTypes.comma);
                  if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(tokTypes.braceR)) { break }
              } else { first = false; }
              node.properties.push( parseProperty() );
            }
            typeName = "TypeObjectDefinition";

        }else if( this.eat(tokTypes.parenL) ){
            const result = this.testTupleUnion();
            if( result && !result.arrow && result.array){
               node = this.parseTypeStatement();
               this.expect( tokTypes.parenR );
               this.expect( tokTypes.bracketL );
               this.expect( tokTypes.bracketR );
               typeName = "TypeTupleUnionDefinition";
            }else{
                const params = this.parseBindingList(tokTypes.parenR, false, this.options.ecmaVersion >= 8);
                this.expect( tokTypes.arrow );
                node.params = params;
                node.value = this.parseTypeStatement();
                typeName = "TypeFunctionDefinition";
            }
        }else if( tokTypes.name === this.type && this.value ==="keyof"){
            this.next();
            node.value = this.parseTypeStatement();
            typeName = "TypeKeyofDefinition";
        }else if( tokTypes.num === this.type || tokTypes.string === this.type || tokTypes._null === this.type || tokTypes._true === this.type ||  tokTypes._false === this.type ){
            node.value = this.parseExprAtom()
        }
        else{
            this.unexpected();
        } 

        let unions = [node];
        this.finishNode(node, typeName)
        while( this.eat(tokTypes.bitwiseOR) ){
            unions.push( this.parseTypeStatement() );
        }
        if( unions.length > 1 ){
            const unionNode = this.startNodeAt(start,startLoc);
            unionNode.elements = unions;
            return this.finishNode(unionNode,"TypeUnionDefinition");
        }
        return node;
    }

    parseAnnotation( nonStatement ){
        const node = this.startNode();
        this.next();
        node.name = this.value;
        this.next();
        if( this.eat( tokTypes.parenL ) ){
            node.body = [];
            const getNode = ()=>{
                var startPos = this.start, startLoc = this.startLoc;
                const base = this.parseExprAtom();
                switch( base.type ){
                    case 'Literal' :
                        if( base.regex )this.raise(this.pos,`Annotation expression parameters can only is scalar type`);
                        return base;
                    case 'Identifier' :
                        return this.parseSubscripts(base, startPos, startLoc, true);
                    default :
                        this.raise(this.pos,`Annotation expression parameters can only is scalar type`);
                }
            }
            while( this.type !== tokTypes.parenR ){
                var startPos = this.start, startLoc = this.startLoc;
                let elem = getNode();
                if( this.eat(tokTypes.eq) ){
                    if( elem.type !=="Identifier" ){
                        this.raise(this.pos,`Assignment expression left-hand must is identifier`);
                    }
                    const left = elem;
                    elem = this.startNodeAt(startPos,startLoc);
                    elem.left = left;
                    elem.right = getNode();
                    this.finishNode(elem, "AssignmentPattern");
                }
                node.body.push( elem );
                if( !this.eat(tokTypes.comma) ){
                    break;
                }
            }
            this.expect( tokTypes.parenR );
        }
        if( nonStatement === true ){
            this.finishNode(node, "AnnotationExpression");
            if( this.canInsertSemicolon() ){
                this.semicolon();
            }
            return node;
        }else{
            this.semicolon();
            return this.finishNode(node, "AnnotationDeclaration");
        }
    }

    parseMetatype(){
        const node = this.startNode();
        node.name = this.value;
        this.next();
        if( this.eat( tokTypes.parenL )  ){
            node.body = [];
            while( this.type !== tokTypes.parenR ){
                const elem = this.startNode();
                const left = this.startNode();
                elem.name = this.value;
                left.name = this.value;
                this.next();
                if( this.eat(tokTypes.eq) ){
                    elem.left =  this.finishNode(left,"Identifier")
                    elem.right = this.parseMaybeAssign();
                }
                node.body.push( elem )
                if( elem.right ){
                    this.finishNode(elem, "AssignmentPattern");
                }else{
                    this.finishNode(elem, "Identifier");
                }
                if( !this.eat(tokTypes.comma) ){
                    break;
                }
            }
            this.expect( tokTypes.parenR );
        }
        this.expect( tokTypes.bracketR );
        this.semicolon();
        return this.finishNode(node, "MetatypeDeclaration");
    }

    parseModifier(){
        let staticNode = this.parseMethodStatic();
        let modifier = this.startNode();
        modifier.name = "public";
        for(let name of ["public","protected","private"] ){
            if( this.eat( tokTypes[ "_"+name ] ) ){
                modifier.name = name;
                break;
            }
        }
        this.finishNode(modifier, "ModifierDeclaration");
        if( !staticNode ){
            staticNode = this.parseMethodStatic();
        }
        return [modifier,staticNode];
    }

    parseMethodStatic(){
        let staticNode = null;
        if( tokTypes._static === this.type ){
            staticNode = this.startNode();
            staticNode.name = "static";
            this.next();
            this.finishNode(staticNode, "ModifierDeclaration");
        }
        return staticNode;
    }

    parseClassProperty(node,kind){
        node = this.parseVarStatement( node, this.value );
        if( node.declarations.length > 1){
            this.raise( node.start, `Only one class property member can be defined in a declaration`);
        } 
        return this.finishNode(node, "PropertyDefinition");        
    }

    parseClass(node, isStatement){
        this.getComments(node);
        node = super.parseClass(node, isStatement);
        return node;
    }

    parseClassElement( constructorAllowsSuper ){
        if( this.eat( tokTypes.bracketL ) ){
            return this.parseMetatype();
        }
        if( this.type === tokTypes._annotation ){
            return this.parseAnnotation();
        }
        const comments = this.getComments();
        const modifier = this.parseModifier();
        const isProperty = this.type === tokTypes._const || this.type === tokTypes._var;
        const element = isProperty ? this.parseClassProperty( this.startNode(), this.value ) : super.parseClassElement( constructorAllowsSuper );
        element.comments=comments;
        if ( modifier[0] ){
            element.modifier =  modifier[0];
        }
        if( modifier[1] ){
            element.static =  modifier[1];
        }
        return element;
    }

    parseImport(node){
        this.next();
        if( this.type !== tokTypes.name ){
            this.unexpected();
        }
        node.specifiers=  this.parseChainIdentifier();
        if( this.eat(tokTypes._as) ){
            if( this.type !== tokTypes.name ){
                this.unexpected();
            }
            node.alias = super.parseIdent();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
    }

    parseExport(){
        this.raise( this.lastTokStart, `Class do not need to use an export.`);
    }

    parsePackage(node, isStatement){
        this.getComments(node);
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node.body = [];
        node.id = null;
        if( this.type === tokTypes.semi ){
            this.next();
        }else if( tokTypes.braceL !== this.type ){
            node.id = this.parseChainIdentifier();
            if( this.type === tokTypes.semi ){
                this.next();
            }
        }

        const metatype = ()=>{
            if( this.eat( tokTypes.bracketL ) ){
                return this.parseMetatype();
            }
            if( this.type === tokTypes._annotation ){
                return this.parseAnnotation();
            }
            return null;
        }

        if( this.eat(tokTypes.braceL) ){
            node.isBlock = true;
            while( !this.eat(tokTypes.braceR) ){
                const item = metatype();
                if( item ){
                    node.body.push(item);
                }else{
                    node.body.push(this.parseStatement(null,true));
                }
            }
        }else{
            node.isBlock = false;
            while( tokTypes.eof !== this.type ){
                const item = metatype();
                if( item ){
                    node.body.push(item);
                }else{
                    node.body.push(this.parseStatement(null,true));
                }
            }
        }

        this.strict = oldStrict;
        return this.finishNode(node,  "PackageDeclaration")
    }
}

Parser.extend(function(){
    return SyntaxParser;
});

SyntaxParser.parse = function parse (input, options) {
    options = Object.assign( {preserveParens:true}, options||{} )
    return new SyntaxParser(options, input).parse()
};

SyntaxParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
    options = Object.assign( {preserveParens:true}, options||{} )
    var parser = new SyntaxParser(options, input, pos);
    if( options.isMethod ){
       parser.enterScope( functionFlags( !!options.isAsync, !!options.generator) | SCOPE_SUPER | ( !!options.allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    }
    parser.nextToken();
    return parser.parseExpression();
};

module.exports= {
    acorn,
    Parser:SyntaxParser
}