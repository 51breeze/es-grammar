const GenericValueType = require('../types/GenericValueType');
const Utils = require("./Utils");
const EventDispatcher = require("./EventDispatcher.js");
class Stack extends EventDispatcher{
    constructor(compilation,node,scope,parentNode,parentStack){
       super(); 
       this.compilation  = compilation;
       this.compiler = compilation.compiler;
       this.isStack = true;
       this.node    = Object.freeze(node);
       this.scope   = scope;
       this.parentNode  = parentNode;
       this.parentStack  = parentStack;
       this.childrenStack = [];
       this.namespace = null;
       this.module    = null;
       this.file = compilation.file;
       if( parentStack ){
           parentStack.childrenStack.push(this);
           this.namespace = parentStack.namespace;
           this.module = parentStack.module;
       }
       if(node){
           if( compilation.compiler.options.service ){
               this.compilation.addStack( this );
           }
           this.comments = node.comments;
       }
    }

    createCompleted(){}

    getDescribe( key, isStatic ){
        const module = this.module;
        if( isStatic ){
            return module.getMethod( key );
        }
        return module.getMember( key );
    }

    getGlobalTypeById(id){
        const value = this.compilation.getGlobalTypeById( id );
        if( !value ){
            this.error(1083,id);
        }
        return value;
    }

    getTypeById(id){
        if( this.module ){
            let type = this.module.namespace.get( id ) || this.module.getImport(id);
            if( type ){
                const aliasName = this.module.importAlias.get( type );
                if(aliasName && aliasName !== id){
                    return null;
                }
                return type;
            }
        }
        return this.compilation.getTypeById(id);
    }

    getModuleById(id){
        if( this.module ){
            let type = this.module.namespace.get( id ) || this.module.getImport(id);
            if( type ){
                const aliasName = this.module.importAlias.get( type );
                if(aliasName && aliasName !== id){
                    return null;
                }
                return type;
            }
        }
        if(this.namespace && this.namespace.has(id)){
            return this.namespace.get( id );
        }
        return this.compilation.getModuleById(id);
    }
    getLocation(){
       return this.node.loc || null;
    }
    getParentStackByName( name ){
        let parent = this.parentStack;
        while( parent && !Utils.isStackByName(parent,name) ){
            parent = parent.parentStack;
        }
        return parent;
    }
    getParentStack( callback ){
        let parent = this.parentStack;
        while( parent && callback(parent) === false && parent.parentStack){
            parent = parent.parentStack;
        }
        return parent;
    }
    completion(){
        return null;
    }
    definition(){
        if( this.parentStack ){
            return this.parentStack.definition();
        }
        return null;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [];
    }
    description(){
        return this;
    }
    type(){
        return null;
    }
    getGenericTypes(){
        return null;
    }
    getRelatedGenericType(relatedGenericTypes, genericType, flag=false, noWrap=false){
        let value = null;
        if( genericType.isGenericType ){
            if( relatedGenericTypes && relatedGenericTypes.size > 0){
                let object = genericType;
                do{
                    value = relatedGenericTypes.get( object );
                    object = object.assignType || object.inherit;
                }while( !value && object && object.isGenericType );
                if( !value && object && object !== genericType ){
                    value = object;
                }
                if( value ){
                    value = !noWrap ? new GenericValueType(value, genericType) : value;
                }else{
                    value = new GenericValueType(null, genericType);
                }
            }else if( !(genericType.hasConstraint || genericType.assignType) ){
                value = this.getGlobalTypeById("any");
            }
        }
        if( flag && !value ){
            value = genericType;
        }
        return value;
    }
    getTypeByGeneric(genericType, flag= true, noWrap=false){
        if( genericType && genericType.isGenericType ){
            return this.getRelatedGenericType(this.getGenericTypes(),genericType,flag, noWrap);
        }
        return genericType;
    }
    inference(target,noWrap=false){
        if( !target ){
            target = this;
        }
        return (type)=>{
            const desc = target.description();
            if( desc.isParamDeclarator ){
                return desc.getTypeByGeneric( type, true, noWrap );
            }
            return target.getTypeByGeneric( type, true, noWrap );
        }
    }
    getFunType(){
        return null;
    }
    value(){
        return this.node.name || this.node.value;
    }
    raw(){
        if( this.compilation && this.compilation.source ){
           return this.compilation.source.substr(this.node.start, this.node.end - this.node.start);
        }
        return this.node.raw || this.node.name;
    }
    checker(){
        if( this.__checked )return false;
        return this.__checked = true;
    }
    parser(){
        if( this.__parsered )return false;
        return this.__parsered = true;
    }
    addUseRef(stack){}
    setRefBeUsed( description ){
        const desc = description || this.description();
        if( desc && desc instanceof Stack && desc !== this ){
            desc.addUseRef( this );
        }
    }
    freeze( target ){
        Object.freeze( target || this);
    }
    error(code, ...args){
        this.compilation.error(this.node,code,...args);
    }
    warn(code, ...args){
        this.compilation.warn(this.node,code,...args);
    }
    toString(){
        return 'Stack';
    }
}


module.exports = Stack;
