const Type = require("../types/Type");
const Utils = require("./Utils");
class Module extends Type{

    constructor( compilation ){
        super(null,null);
        this.compilation = compilation;
        this.static = false;
        this.abstract = false;
        this.isClass  = false;
        this.isInterface  = false;
        this.isEnum  = false;
        this.isDeclaratorModule = false;
        this.namespace = null;
        this.implements=[];
        this.methods={};
        this.members={};
        this.annotations =[];
        this.metatypes = [];
        this.making = false;
        this.dependencies=new Set();
        this.imports=new Map();
        this.importAlias=new Map();
        this.isModule = true;
        this.methodConstructor = null;
        this.comments = null;
        this.file = null;
        this.used = false;
        this.callable = null;
        this.children =[];
        this.policy = null;
        this.dynamic = false;
    }

    definition(){
        const stack = this.compilation.getStackByModule( this );
        if( stack ){
            const kind = this.isInterface ? "interface" : this.isEnum ? "enum" : "class";
            return {
                kind:kind,
                comments:this.comments,
                expre:`${kind} ${this.toString(true)}`,
                location:(stack.id || stack).getLocation(),
                file:this.file,
                context:stack
            };
        }
        return null;
    }

    getName(segment='.',suffix=null){
        let name = this.id;
        if( this.namespace ){
            name = this.namespace.getChain().concat(this.id).join( segment )
        }
        return suffix ? name+this.compilation.compiler.suffix : name;
    }

    check( stack ){
        const type = stack && stack.type();
        if( !type )return false;
        if( type.isEnumType && type.owner){
            return type.owner === this;
        }
        return this.is(type);
    }

    is( type ){
        if( !type )return false;
        if( type.isAnyType || type.isNullableType )return true;
        if( this.id==="Interface" && (!this.namespace || this.namespace.identifier==='') && Utils.isInterface(type) ){
            return true;
        }
        
        const nullType = this.compilation.getGlobalTypeById("nullable");
        const objectType = this.compilation.getGlobalTypeById("Object");
        const classType = this.compilation.getGlobalTypeById("Class");

        if( this === objectType && !Utils.isScalar( type ) ){
            return true;
        }

        if( this === classType ){
            if( type.isClassGenericType && type.extends[0]){
                type = type.extends[0];
            }
            return !!(type instanceof Module && type.isClass);
        }

        type = Utils.getOriginType( type );
        if( type === nullType || type === this ){
            return true;
        }

        if( !(type instanceof Module) ){
            return false;
        }

        const check = (left,right)=>{
            if( left === right ){
                return true;
            }
            if(right.extends && right.extends.some(right=>check(left, right))){
                return true;
            }
            if(right.implements && right.implements.length > 0){
                return right.implements.some(right=>check(left,right));
            }
            return false;
        }
        if( type.isInterface ){
            return check(type,this);
        }
        return check(this,type);
    }

    publish(){
        const alias = this.metatypes.find( item=>item.name==="Alias" );
        if( alias ){
            const metatype = {};
            alias.params.forEach( item=>{
                const name  = item.value ? item.name : "name";
                const value = item.value ? item.value : item.name;
                metatype[ name ] = value;
            });
            this.alias = metatype.name;
            this.namespace.set(metatype.name, this);
            if( Boolean(metatype.origin) !== false ){
               this.namespace.set(this.id, this);
            }
        }else{
            this.namespace.set(this.id, this);
        }
    }

    getMethod( name, kind=null){
        const target = Object.prototype.hasOwnProperty.call(this.methods,name) ? this.methods[name] : null;
        if( target && target.isAccessor ){
            return kind =="set" ? target.set : target.get;
        }
        return target;
    }

    getMember( name, kind=null){
        let members = this.members;
        let inherit  = this;
        while( !Object.prototype.hasOwnProperty.call(members,name) ){
            if( inherit.extends[0] && inherit.extends[0].members){
                inherit = inherit.extends[0];
                members = inherit.members;
            }else{
                inherit = this.compilation.getModuleById("Object");
                members = inherit.members;
                break;
            }
        }
        let target = members && Object.prototype.hasOwnProperty.call(members,name) ? members[name] : null;
        if( target && target.isAccessor ){
            return kind =="set" ? target.set : target.get;
        }
        if( !target && this.isDeclaratorModule ){
            return this.getInterfaceMember(name,kind);
        }
        return target;
    }

    getInterfaceMember(name, kind=null){
        const imps = this.implements;
        const len  = imps.length;
        for(let i=0;i<len;i++){
            const impModule = imps[i];
            const result = impModule.getMember(name, kind);
            if( result ){
                return result;
            }
        } 
        return null;
    }

    getConstructMethod(){
        return this.methodConstructor || null;
        // let inherit = this;
        // while( inherit ){
        //     let method = inherit.methodConstructor;
        //     if( method )return method;
        //     inherit = inherit.extends ? inherit.extends[0] : null;
        // }
        // return null;
    }

    addDepend(module){
        if( module !== this ){
            module.used = true;
            this.dependencies.add(module);
        }
    }

    getReferenceNameByModule(module){
       if( module === this ){
           return module.id 
       }
       if( this.imports.has( module.id ) && this.imports.get(module.id).namespace === module.namespace){
          return module.id;
       }
       if( this.importAlias.has(module) ){
           return this.importAlias.get(module);
       }
       return module.namespace.getChain().concat(module.id).join("_");
    }

    addMember(name, desc, flag=false){
        if(desc && desc.isConstructor){
            if( this.methodConstructor && (!this.isDeclaratorModule || this.compilation === desc.compilation) ){
                desc.error(1045,'constructor');
            }
            this.methodConstructor =  desc;
        }else{
            const isStatic = !!desc.static;
            const target = isStatic || flag ? this.methods : this.members;
            if( desc.kind ==="get" || desc.kind ==="set" ){
                const obj = Object.prototype.hasOwnProperty.call(target,name) ? target[ name ] : (target[ name ]={isAccessor:true});
                if(!obj.isAccessor || Object.prototype.hasOwnProperty.call(obj,desc.kind) ){
                    if( !this.isDeclaratorModule || this.compilation === desc.compilation ){
                        desc.error(1045,name);
                    }
                }
                obj[ desc.kind ] = desc;
            }else{
                if( ( !this.isDeclaratorModule || this.compilation === desc.compilation ) && Object.prototype.hasOwnProperty.call(target,name) ){
                    desc.error(1045,name);
                }
                target[ name ] = desc;
            }
        }
    }

    addImport(name, module, isAlias=false ){
        if( module === this ){
            return false;
        }
        if( this.imports.has(name) ){
            return false;
        }
        if( isAlias ){
            this.importAlias.set(module,name);
        }
        this.imports.set(name, module);
        return true;
    }

    getImport(name){
        return this.imports.get(name);
    }

    getModuleGenerics(){
        const stackModule = this.compilation.getStackByModule( this );
        if( stackModule && stackModule.genericity ){
           return stackModule.genericity.elements.map( item=>item.type() );
        }
        return null;
    }

    toString( flag, inference ){
        const name = this.namespace.getChain().concat( this.id ).join(".");
        const stackModule = this.compilation.getStackByModule( this );
        if( stackModule && stackModule.genericity ){
           const elements = stackModule.genericity.elements.map( item=>item.type().clone(inference).toString(flag) )
           return `${name}<${elements.join(",")}>`
        }
        return name;
    }
}
module.exports = Module;