const fs     = require("fs");
const path     = require("path");
const TopScope = require("../scope/TopScope.js");
const Parser = require("./Parser.js");
const Namespace = require("./Namespace.js");
const Module = require("./Module");
const Utils  = require("./Utils.js");
const Diagnostic  = require("./Diagnostic.js");
const Range  = require("./Range.js");
const EventDispatcher = require("./EventDispatcher.js");
const moduleStacks = new Map();
const symbolKey = Symbol('key');
class Compilation extends EventDispatcher{

    constructor( compiler, file ){
        super(); 
        this.compiler = compiler;
        this.modules = new Map();
        this.stacks = new Map();
        this.namespace = null;
        this.children = [];
        this.parent = null;
        this.scope= new TopScope(null);
        this.stack=null;
        this.ast = null;
        this.isDescriptionType = false;
        this.isMain = false;
        this.errors = [];
        this.mtime = null;
        this.file = file;
        this.owner = null;
        this[symbolKey]={
            policy:Compilation.POLICY_NONE,
            completed:{},
            dependencies:new Set(),
        };
    }

    completed(syntax, value){
        if( value !== void 0 ){
            this[symbolKey].completed[syntax] = value;
        }
        return !!this[symbolKey].completed[syntax];
    }

    get policy(){
        return this[symbolKey].policy;
    }
    
    setPolicy(policy, module){
        if( (Compilation.POLICY_ALL & policy) === policy){
            if( module ){
                module.policy=policy;
            }else{
                this[symbolKey].policy = policy;
                this.modules.forEach( module=>{
                    module.policy=policy;
                });
            }
        }
    }

    isPolicy(policy, module){
        const value = module ? module.policy : this.policy;
        return (value & policy) === value;
    }

    isServerPolicy(module){
        const value = module ? module.policy : this.policy;
        if( value === Compilation.POLICY_ALL ){
            return true;
        }
        return (value & Compilation.POLICY_SERVER) === value;
    }

    isClientPolicy(module){
        const value = module ? module.policy : this.policy;
        return value !== Compilation.POLICY_SERVER;
    }

    addStack( stack ){
        if( stack.node.start > 0 ){
            this.stacks.set(stack.node.start,stack);
        }
    }

    addDependency(dep, module){
        if( dep && dep !== this ){
            if( module ){
                module.isModule && module.addDepend(dep);
            }else{
                dep.used = true;
                this[symbolKey].dependencies.add(dep); 
            }
        }
    }

    getDependencies( module ){
        if( module ){
            return module.isModule ? Array.from( module.dependencies.values() ) : [];
        }
        const items = new Set();
        this[symbolKey].dependencies.forEach(item=>items.add(item));
        this.modules.forEach( item=>{
            item.dependencies.forEach( item=>{
                items.add( item );
            });
        })
        return Array.from( items.values() );
    }

    getStackByAt( startAt, trys=3, both=0){
        let stack = this.stacks.get( startAt );
        if( !stack ){
            let offset = 0;
            if(trys < 0){
                trys =  this.source.length / 2;
            }
            while(!stack && offset < trys){
                offset++;
                if( both === 0 ){
                   stack = this.stacks.get( startAt - offset ) || this.stacks.get( startAt + offset );
                }else if( both < 0 ){
                   stack = this.stacks.get( startAt - offset )
                }else if( both > 0){
                   stack = this.stacks.get( startAt + offset )
                }
            }
        }
        return stack;
    }

    addModuleStack(module,stack){
        moduleStacks.set(module,stack);
    }

    getStackByModule(module){
        return moduleStacks.get(module);
    }

    error(node,code,...args){
        const range = this.getRangeByNode( node );
        const message = Diagnostic.getMessage(this.compiler.options.lang,code,args);
        const error = new Diagnostic(this.file, message, range , 0, node, code);
        if(this.compiler.options.diagnose){
            this.errors.push(error);
            this.compiler.errors.push( error );
        }else{
            if( this.compiler.options.debug){
                throw (node instanceof Error ? node : new Error(error.toString()));
            }else{
                Utils.error(error.toString());
            }
        }
    }

    warn(node,code,...args){
        const range = this.getRangeByNode(node);
        const message = Diagnostic.getMessage(this.compiler.options.lang,code,args);
        const warn = new Diagnostic(this.file, message, range , 1, node,code);
        if( this.compiler.options.diagnose){
            this.errors.push( warn );
            this.compiler.errors.push( warn );
        }else{
            Utils.warn(warn.toString());
        }
    }

    getReference(key,target,isStatic,kind=null){
        if( target && target instanceof Module ){
            if( isStatic ){
                return target.getMethod( key, kind );
            }
            return target.getMember( key, kind );
        }else if( target instanceof Namespace ){
            return target.get( key )
        }
        return !target ? this.getModuleById( key ) : null;
    }

    getRangeByNode( node ){
        if( node.loc){
            if( node.loc.start && node.loc.end){
                return new Range(node.loc.start,node.loc.end);
            }else{
                return new Range(node.loc, Object.assign({},node.loc,{column:node.loc.column+(node.raisedAt-node.pos)}));
            }
        }
        const str = this.source.substr(0,node.start+1);
        const lines=str.split(/\r\n/);
        const startLineText = lines.length > 0 ? lines[lines.length-1] : str;
        const column = node.start - (str.length - startLineText.length);
        const start  = {line:lines.length,column};
       
        const endStr = this.source.substr(node.start,node.end+1);
        const endLines=endStr.split(/\r\n/);
        const endLineText = endLines.length > 0 ? endLines[endLines.length-1] : endStr;
        const endColumn  = node.end - (endStr.length - endLineText.length);
        const end        = {line:endLines.length+lines.length,column:endColumn};
        return new Range(start,end);
    }

    getTypeById(id){
        if( this.modules.has(id) ){
            return this.modules.get(id);
        }
        return Namespace.fetch(id);
    }

    getGlobalTypeById(id){
        return Namespace.fetch(id);
    }

    getModuleById(id,flag=false){
        if( this.modules.has(id) ){
            return this.modules.get(id);
        }
        let type = Namespace.fetch(id);
        if( !type ){
            const compilation = this.compiler.createCompilation( id.replace(/\./g,'/'), this.file && path.dirname(this.file) );
            if( compilation ){
                compilation.parent = this;
                if( !compilation.stack ){
                    compilation.createStack();
                    this.children.push(compilation);
                    if( flag ){
                        compilation.parser();
                        compilation.checker();
                    }
                }
                return compilation.modules.get(id);
            }
            return false;
        }
        return type;
    }

    getAllModulesByPolicy( policy ){
        const modules = [];
        this.modules.forEach( module=>{
            if( this.isPolicy(policy,module) ){
                modules.push(module);
            }
        });
        this.children.forEach( childCompilation=>{
            const result = childCompilation.getModulesByPolicy(policy);
            for( const item of result ){
                modules.push(item);
            }
        });
        return modules;
    }

    getModulesByPolicy( policy ){
        const modules = [];
        this.modules.forEach( module=>{
            if( this.isPolicy(policy,module) ){
                modules.push(module);
            }
        });
        this.children.forEach( childCompilation=>{
            childCompilation.modules.forEach( module=>{
                if( childCompilation.isPolicy(policy,module) ){
                    modules.push(module);
                }
            });
        });
        return modules;
    }

    getServerComplilations(){
        const complilations = [];
        const map = new WeakSet();
        const push = (compilation)=>{
            if( !map.has(compilation) ){
                map.add( compilation );
                complilations.push(compilation);
            }
        }
        this.modules.forEach( module=>{
            if( this.isServerPolicy(module) ){
                push(module.compilation);
            }
        });
        this.children.forEach( child=>{
            child.getServerComplilations().forEach( compilation=>{
                push( compilation );
            });
        });
        return complilations;
    }

    getClinetComplilations(){
        const complilations = [];
        const map = new WeakSet();
        const push = (compilation)=>{
            if( !map.has(compilation) ){
                map.add( compilation );
                complilations.push(compilation);
            }
        }
        this.modules.forEach( module=>{
            if( this.isClientPolicy(module) ){
                push(module.compilation);
            }
        });
        this.children.forEach( child=>{
            child.getServerComplilations().forEach( compilation=>{
                push( compilation );
            });
        });
        return complilations;
    }

    readSibling(flag=false, context=''){
        const dir = this.file && path.dirname(this.file)
        if( dir ){
            const files = (Utils.readdir(path.join(dir,context.replace('.','/')), true) || []).map( filename=>{
                const stat = fs.statSync(filename);
                const folder = stat ? stat.isDirectory() : false;
                const name = path.basename(filename, this.compiler.suffix);
                return {name,folder,filename};
            });
            if( flag ){
                const uniqueNs = new Set();
                Array.from(this.modules.values()).forEach( module=>{
                    uniqueNs.add( module.namespace );
                });
                const list = [];
                uniqueNs.forEach( ns=>{
                    files.forEach( item=>{
                        item.name = ns.getChain().concat(item.name).join(".");
                        list.push( item );
                    })
                });
                return list;
            }
            return files;
        }
        return [];
    }

    createAst(source){
        if( !this.ast ){
            try{
                if( this.ast ){
                    if( this.file ){
                        const mtime = fs.statSync(this.file).mtimeMs;
                        if( mtime === this.mtime ){
                            return this.ast;
                        }
                        this.mtime = mtime;
                    }else if( source === this.source ){
                        return this.ast;
                    }
                }else if( this.file ){
                    this.mtime = fs.statSync(this.file).mtimeMs;
                }
                this.source = source || fs.readFileSync(this.file).toString();
                this.ast = Parser.Parser.parse(this.source,this.compiler.options.parser);
            }catch(e){
                this.error(e,1085,e.message);
            }
        }
        return this.ast;
    }

    createModule(namespace,id){
        let name = id;
        if( namespace ){
            if( namespace.has(id) ){
                return namespace.get(id);
            }
            name = namespace.getChain().concat(name).join('.');
        }
        let module = this.modules.get(name);
        if( !module ){
            module = new Module(this);
            module.file = this.file;
            module.namespace = namespace;
            module.policy = this.policy;
            module.id = id;
            if( namespace ){
                namespace.set(id,module);
            }
            this.modules.set(name,module);
            this.compiler.dispatcher('onCreatedModule',module);
        }
        return module;
    }
    
    createStack(source){
        if( !this.stack ){
            const old = this.ast;
            const ast = this.createAst(source);
            if( old !== ast ){
                this.stack = Utils.createStack(this,ast,this.scope,null);
            }
        }
        return this.stack;
    }

    clear( flag ){
        if( flag !== true ){
            if( this.file ){
                const mtime = fs.statSync(this.file).mtimeMs;
                if( mtime === this.mtime ){
                    return false;
                }
            }else if( source === this.source ){
                return false;
            }
        }
        
        this.modules.forEach((module)=>{
            module.dependencies.clear();
            moduleStacks.delete(module)
            module.namespace.del( module.id );
        });

        const ns = this.namespace;
        if( ns ){
            ns.modules.forEach( (item,name)=>{
                if(item.compilation === this){
                    ns.del(name);
                }
            });
        }

        this.errors.forEach( error=>{
            const index = this.compiler.errors.indexOf(error);
            if( index>= 0 ){
                this.compiler.errors.splice(index,1);
            }
        });

        this.modules.clear();
        this.stacks.clear();
        this.changed = !!this.ast;
        this.errors = [];
        this.scope  = new TopScope(null);
        this.stack  = null;
        this.ast    = null;
        this.hasParsed = false;
        this.hasChecked = false;
        this.hasFreezed = false;

        this[symbolKey].dependencies

        const data = this[symbolKey];
        data.completed={};
        data.policy = Compilation.POLICY_NONE;
        data.dependencies.clear();
        return true;
    }

    clearAndCreateStack(source){
        this.clear();
        return this.createStack(source);
    }

    parser( source=null ){
        if( !this.hasParsed ){
            this.hasParsed = true;
            this.createStack( source );
            if( this.stack ){
                this.compiler.dispatcher('onParseStart',{compilation:this});
                this.children.forEach( child=>child.parser() );
                this.stack.parser();
                this.compiler.dispatcher('onParseDone',{compilation:this});
            }
        }
    }

    checker(){
        if( !this.hasChecked ){
            this.hasChecked = true;
            if( this.stack ){
                this.children.forEach( child=>child.checker() );
                this.stack.checker();
            }
        }
    }

    freeze(){
        if( !this.hasFreezed ){
            this.hasFreezed = true;
            if( this.stack && this.compiler.options.freeze ){
                //Object.freeze(this);
                this.stack.freeze();
                this.children.forEach( child=>child.freeze() );
            }
        }
    }

    batch( plugins, completed ){
        var task = plugins.length;
        const errors = [];
        plugins.forEach((plugin)=>{
            process.nextTick((plugin)=>{
                const done = (error)=>{
                    task--;
                    if(error){
                        errors.push(error);
                    }
                    if( task < 1 ){
                        if( completed && typeof completed==="function"){
                            completed( errors.length > 0 ? errors : null, this); 
                        }
                    }
                };
                this.build(plugin,done,true);
            },plugin);
        });
    }

    build(plugin, completed, flag=false){
        const compilation = this;
        const done = (error)=>{
            this.compiler.dispatcher('onBuildDone', {error,plugin,compilation});
            if( completed && typeof completed==="function"){
                if( error && error instanceof Error ){
                    completed({plugin,error},this);
                }else{
                    completed(null,this);
                }
            }
        };
        try{
            this.parser();
            this.checker();
            if( this.stack ){
                this.freeze();
                this.compiler.dispatcher('onBuildStart',{plugin,compilation});
                if( flag===true ){
                    plugin.start(this, done);
                }else{
                    plugin.build(this, done);
                }
            }else{
                done( new Error('Parser error.') );
            }
        }catch(error){
            done(error);
        }
    }
}

Compilation.POLICY_NONE=1;
Compilation.POLICY_SERVER=2;
Compilation.POLICY_CLIENT=4;
Compilation.POLICY_ALL=7;

module.exports = Compilation;
