const Compilation  = require("./Compilation");
const Lodash  = require("lodash");
const path   = require("path");
const cwd    = process.cwd();
const fs = require("fs");
const MemoryFileSystem = require("memory-fs");
const Utils = require("./Utils");
const dirname = __dirname;
const compilations = new Map();
const EventDispatcher = require("./EventDispatcher.js");
const Diagnostic  = require("./Diagnostic.js");
const pluginInterfaces=[
    {name:'name',type:['string']},
    {name:'platform',type:['string']},
    {name:'version',type:['string','number']},
    {name:'config',type:['function']},
    {name:'start',type:['function']},
    {name:'build',type:['function']},
];
const plugins=new Map();
class Compiler extends EventDispatcher{
    static getCompilations(){
        return compilations;
    }
    constructor(options){
        super(); 
        options = this.parseOptions(options);
        this.options = options;
        this.compilations = compilations;
        this.suffix = this.options.suffix;
        this.main = [];
        this.regexpSuffix = new RegExp(`(\\w+)(${this.suffix.replace(".","\\.")})$`,'i');
        this.workspace = options.workspace;
        this.globalPath = path.resolve(dirname,'../globals');
        this.filesystem = new Map();
        this.grammar  = new Map();
        this.errors=[];
        this.loadedDescribeFiles = new Set();
    }

    callUtils(name, ...args){
        const fun = Utils[name];
        return fun ? fun.apply(Utils, args) : false;
    }

    defaultOptions(){
        return {
            "throwError":false,
            "debug":true,
            "diagnose":false,
            "workspace":"./",
            "service":false,
            "lang":1,
            "suffix":".es",
            "builder":[],
            "types":[],
            "env":'production',
            "freeze":false,
            "annotations":[
                'Provider','Callable','Runtime','Syntax','Env','Router','Post','Get','Del','Put','Option','Deprecated','Override','Dynamic'
            ],
            "excludeDescribeFile":[],
            "loadGlobalDescribeFile":true,
            "autoLoadDescribeFile":false,
            "describePattern":/(\.d\.es)$/,
            "parser":{
                "locations":false,
                "preserveParens":true,
                "reserved":["global"],
            }
        }
    }

    parseOptions(options){
        const defaultOptions = this.defaultOptions();
        options =  Lodash.merge(defaultOptions ,options || {});
        if( options.output ){
            options.output = this.pathAbsolute( options.output )
        }else{
            options.output = path.resolve(process.cwd(),'build');
        }
        options.workspace = path.isAbsolute(options.workspace) ? options.workspace : path.resolve( process.cwd(), options.workspace);
        options.builder = (options.builder || []).map( name=>{
            try{
                return require(name);
            }catch(e){
                return null;
            }
        }).filter(value=>!!value);
        return options;
    }

    getOutputFileSystem(syntax){
        const key = `${syntax}-output`;
        if( this.filesystem.has(key) ){
            return this.filesystem.get(key);
        }
        const filesystem =  new MemoryFileSystem();
        this.filesystem.set(key, filesystem);
        return filesystem;
    }

    getInputFileSystem(){
        const key = `input`;
        if( this.filesystem.has(key) ){
            return this.filesystem.get(key);
        }
        const filesystem =  new MemoryFileSystem();
        this.filesystem.set(key, filesystem);
        return filesystem;
    }

    getFileAbsolute(file, context){
        if( typeof file !== "string" )return null;
        if( !this.regexpSuffix.test( file ) ){
            file =file+this.suffix;
        }
        if( path.isAbsolute( file )){
            file = path.resolve(file);
        }else{
            if( context ){
                const section = context.replace(/\\/g,'/').split('/');
                let root = context;
                while( root && !fs.existsSync( path.join(root,file) ) && section.pop() ){
                    root = section.join("/");
                }
                if( root ){
                    file = path.join(root, file);
                }
                return fs.existsSync(file) ? file : null;
            }
            file = path.resolve(this.workspace,file);
        }
        return fs.existsSync(file) ? file : null;
    }

    pathAbsolute(file){
        return path.isAbsolute( file ) ? path.resolve(file) : path.resolve(cwd,file);
    }

    removeCompilation(file){
        file = this.getFileAbsolute( file );
        const compilation = this.compilations.get( file );
        if( compilation ){
            this.compilations.delete( file );
        }
        return compilation;
    }

    getCompilation(file,context){
        file = this.getFileAbsolute(file,context);
        if( file && this.compilations.has( file ) ){
            return this.compilations.get( file );
        }
        return null;
    }

    hasCompilation(file,context){
        file = this.getFileAbsolute(file,context);
        return this.compilations.has( file );
    }

    createCompilation(file,context){
        file = this.getFileAbsolute(file,context);
        if( file ){
            if( this.compilations.has( file ) ){
                return this.compilations.get( file );
            }
            const compilation = new Compilation(this, file);
            this.compilations.set(file, compilation);
            if( this.options.autoLoadDescribeFile ){
                this.autoLoadDescribeFiles( path.dirname(file) );
            }
            this.dispatcher('onCreatedCompilation',compilation);
            return compilation;
        }
        return null;
    }

    autoLoadDescribeFiles( dirname ){
        if( this.options.autoLoadDescribeFile && dirname && this.globalPath !== dirname ){
            const loaded = this.loadedDescribeFiles;
            dirname = this.pathAbsolute( dirname );
            if( loaded.has(dirname) )return;
            loaded.add( dirname );
            const regexp = this.options.describePattern;
            const types = Utils.readdir(dirname, true).filter( filename=>regexp.test( filename ) );
            if( types.length > 0 ){
                this.loadTypes( types );
            }
            this.autoLoadDescribeFiles( path.dirname( dirname ) );
        }
    }

    initialize(){
        if( !Compiler.globalTypeInitialized ){
            Compiler.globalTypeInitialized = true;
            const types = this.options.loadGlobalDescribeFile ? Utils.readdir(this.globalPath,true) : [];
            this.loadTypes( types, true );
            if( Array.isArray(this.options.types) && this.options.types.length > 0 ){
                this.loadTypes(this.options.types);
            }
            this.dispatcher('initialized');
        }
    }

    loadTypes( types , isGlobal=false, owner=null){
        if( !Compiler.globalTypeInitialized ){
            throw new Error('Please initialize first.');
        }
        if(typeof types ==="string"){
            types = [types];
        }
        if( !Array.isArray(types) ){
            const message = Diagnostic.getMessage(this.compiler.options.lang,1095,[types]);
            throw new Error( message );
        }
        const exclude = Array.isArray(this.options.excludeDescribeFile) ? this.options.excludeDescribeFile : [];
        const compilations =[];
        types.forEach( file=>{
            if( exclude.includes( file ) ){
                return;
            }
            const compilation = this.createCompilation(file);
            if( !compilation.stack ){
                compilation.isDescriptionType = true;
                compilation.isGlobalsDescriptionType = isGlobal;
                compilation.owner = owner;
                compilation.createStack();
                compilations.push( compilation );
            }
        });

        compilations.forEach( compilation=>{
            compilation.parser();
        });

        if( this.errors.length > 0 ){
            const errors = this.errors.map( item=>item.toString() );
            throw new Error( errors.join("\r\n") );
        }
    }

    checkPlugin(plugin){
        const proto = typeof plugin ==="function" ? plugin.prototype : Object.getPrototypeOf(plugin);
        if( !proto ){
            throw new Error( `Invalid plugin.` );
        }
        const result = pluginInterfaces.find( item=>{
            const value = proto[item.name];
            if( !value ){
                throw new Error( `Plugin interface '${item.name}' not implemented.` );
            }
            return !item.type.includes( typeof value );
        });
        if( result ){
            throw new Error( `Plugin interface '${result.name}' implemented members type not compatible. must is "${result.type.join(',')}"` );
        }
    }

    getPlugin( plugin ){
        if( plugins.has(plugin) ){
            return plugins.get(plugin);
        }
        this.checkPlugin( plugin );
        const instance = typeof plugin ==="function" ? new plugin(this) : instance;
        plugins.set(plugin, instance );
        this.dispatcher('pluginInstantiated',{plugin,instance});
        return instance;
    }

    start(plugins, done){
        this.initialize();
        const file = this.options.file;
        const compilation = this.createCompilation( file );
        if( compilation ){
            this.main.push( compilation );
            compilation.isMain = true;
            compilation.batch( [].concat(plugins).map( plugin=>this.getPlugin(plugin) ) , done);
        }
    }

    build(file, plugin, done, clear=false){
        this.initialize();
        const compilation = this.createCompilation( this.getFileAbsolute(file) );
        if( compilation && compilation.stack && clear){
            compilation.clear();
        }
        if( compilation ){
            compilation.isMain = true;
            compilation.build(this.getPlugin(plugin), done);
            return true;
        }
        return false;
    }
}

Compiler.start=( options )=>{
    const compiler = new Compiler( options );
    compiler.start( compiler.options.builder );
}

module.exports = Compiler;
