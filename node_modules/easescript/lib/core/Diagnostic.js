
const constant = {};
const dataset  = {};
const define=(code,name,message)=>{
    if( dataset[code] ){
        throw new Error(`code '${code}' already exists.`)
    }
    dataset[code]  = message;
    constant[name] = code;
}
class Diagnostic{
    constructor(file,message,range,kind,node,code){
        this.file = file;
        this.message = message;
        this.range = range;
        this.kind = kind;
        this.node = node;
        this.code = code;
    }
    toString(){
        let message = this.message;
        let range = this.range;
        if( this.file ){
            message+= ` (${this.file}:${range.start.line}:${range.start.column}) ${this.code}`;
        }else{
            message+= ` (${range.start.line}:${range.start.column}) ${this.code}`;
        }
        return message;
    }
    static defineError(code,name,value){
        define(code,name,value);
    }
    static getCodeByName(name){
        return constant[name];
    }
    static getMessage(id, code, args=[]){
       const message = dataset[code] && dataset[code][id] || 'unknown';
       let index = 0;
       return message.replace(/(%([s|S]|\d+))/g, (name)=>{
            const at = parseInt(name.substr(1,1));
            const result = at > 0 ? args[at-1] : args[index++];
            return result === void 0 ? 'unknown' : result;
       });
    }
}

define(1000,"MISSING_ARGUMENT",[
    "函数参数期望有%s个，当前给了%s个",
    "Expected %s arguments, but got %s"
]);

define(1001,"INCONSISTENT_ARGUMENT",[
    "函数参数期望有%s个，当前给了%s个",
    "Expected %s arguments, but got %s",
]);

define(1002,"TYPE_ASSIGNABLE_NOT_MATCHED",[
    "指定的实参类型(%s), 不能分配给声明的形参类型(%s)",
    `Argument of type '%s' is not assignable to parameter of type '%s'`,
]);

define(1003,"GENERIC_ASSIGNABLE_NOT_CONSTRAINT",[
    "指定泛型参数的类型(%s)与声明的约束泛型类型(%s)不匹配",
    "Type '%s' does not satisfy the constraint '%s'",
]);

define(1004,"GENERIC_ARGUMENT_NUMBER_INCONFORMITY",[
    "泛型参数期望是 %s 个，但指定了 %s 个",
    "Expected %s type arguments, but got %s",
]);

define(1005,"GENERIC_ARGUMENT_NUMBER_INCONFORMITY_RANGE",[
    "泛型参数期望是 %s-%s 个，但指定了 %s 个",
    "Expected %s-%s type arguments, but got %s",
]);

define(1006,"REFS_FUN_IS_NOT_CALLABLE",[
    "引用名(%s)，不是一个可调用的方法",
    "'%s' is not callable",
]);

define(1007,"REFS_VARIABLE_CANNOT_REDECLARE",[
    "变量不能重复声明(%s)",
    "Variable '%s' cannot redeclare",
]);

define(1008,"REFS_VARIABLE_CONFLICTS_WITH_CLASS",[
    "声明的变量名(%s)与类名冲突",
    "Variable '%s' conflicts with the current class name.",
]);

define(1009,"REFS_TYPE_ASSIGNABLE_NOT_MATCHED",[
    "指定引用值的类型(%s)与分配给指定变量的类型(%s)不匹配",
    "Type '%s' is not assignable to assignment of type '%s'",
]);

define(1010,"REFS_VARIABLE_CANNOT_IS_ITSELF",[
    "指定引用的变量不能是自身(%s)",
    "Variable '%s' cannot reference to itself.",
]);

define(1011,"REFS_VARIABLE_CANNOT_IS_ITSELF",[
    "变量名(%s),隐含着(any)类型,但是可以为其赋值后能推断出更适合的类型",
    "Variable '%s' implicitly has an 'any' type, but a better type may be inferred from usage.",
]);

define(1012,"REFS_SPREAD_NOT_IS_ARRAY",[
    "展开数组表达式(%s)的类型必须是一个数组，当前引用的类型(%s)",
    "Spread '%s' expression, must be an array type. give %s",
]);

define(1013,"REFS_IS_NOT_DEFINED",[
    "引用名(%s)没有定义",
    "'%s' is not defined",
]);

define(1014,"REFS_SPREAD_ARRAY_OUT_INDEX_RANGE",[
    "展开数组声明的参数,已超出被引用数组的下标索引元素",
    "Spread arguments out of range, is not assign initial value at %s, in the refs '%s'",
]);

define(1015,"REFS_IS_NOT_WRITABLE",[
    "引用名(%s)是一个不可写的声明",
    "'%s' is not writable",
]);

define(1016,"PARAMETER_CANNOT_HAVE_QUESTION_AND_INITIAL",[
    "有初始值的参数不需要标记为可选参数",
    "Parameter with an initial value cannot be marked as optional",
]);

define(1017,"AWAIT_EXPRESSION_MUST_ASYNC_FUN",[
    "表达式(await),只能引用声明为同步的函数",
    "Await expression are only allowed within async function",
]);

define(1018,"AWAIT_EXPRESSION_MUST_RETURN_PROMISE",[
    "表达式(await),只能引用声明为同步的函数",
    "Await expression needs to return a promise type",
]);

define(1019,"REFS_IS_NOT_INSTANCE_OBJECT",[
    "引用(%s),不是一个实例对象",
    "The refs '%s' is not instance object",
]);

define(1020,"REFS_MAYBE_IS_NOT_INSTANCE_OBJECT",[
    "引用(%s),可能不是一个实例对象",
    "The refs '%s' maybe is not instance object",
]);

define(1021,"OPERATOR_RIGHT_HAND_NOT_IS_CLASS",[
    "实例运算符(%s),在右边表达式中必须是一个类型引用",
    "Operator the '%s' right-hand refs is not class type",
]);

define(1022,"BREAK_JUMP_CANNOT_CROSS_BLOCK",[
    "语法(Break)指定的标签(%s)表达式不存在或者已跨越边界",
    "Jump target is not exists or has crossed boundary",
]);

define(1023,"BREAK_NOT_IN_LOOP",[
    "语法(Break)只能出现在循环语句中",
    "Break must be contain in the 'switch,while,do,for'",
]);

define(1024,"IMPORT_REFS_TO_CIRCULAR_DEPS",[
    "导入指定的模块(%s),是一个循环引用",
    "Import '%s' refs to circular dependency.",
]);

define(1025,"IMPORT_REFS_ALREADY_EXISTS",[
    "导入的模块(%s)已经存在",
    "Import '%s' module already exists.",
]);

define(1026,"IMPORT_REFS_NOT_EXISTS",[
    "导入的模块(%s)没有找到",
    "Import '%s' is not exists.",
]);

define(1027,"CLASS_REFS_NOT_EXISTS",[
    "引用的类(%s)不存在",
    "Class '%s' is not exists",
]);

define(1028,"IMPLEMENTS_REFS_NOT_INTERFACE",[
    "在类的(implements)表达式中,指定的标识符不是接口类型",
    "Implements '%s' is not interface",
]);

define(1029,"IMPLEMENTS_REFS_NOT_INTERFACE",[
    "在类的(implements)表达式中,指定的接口类型不存在",
    "Implements '%s' is not exists",
]);

define(1030,"CLASS_GENERIC_MISSING_ARGS",[
    "指定的泛类型需要有 %s 个类型参数",
    "Generic '%s' requires %s type arguments",
]);

define(1031,"CLASS_GENERIC_MISSING_ARGS_RANGE",[
    "类泛型(%s)需要有 %s-%s 个类型参数",
    "Generic '%s' requires %s-%s type arguments",
]);

define(1032,"INTERFACE_MEMBER_NOT_IMPLEMENTED",[
    "指定的接口成员(%1),没有在此类中实现",
    "The '%s' %s in the %s is not implemented in the %s",
]);

define(1033,"INTERFACE_RETURN_TYPE_NOT_MATCHED",[
    "实现接口成员(%1),返回的类型不兼容",
    "The '%s' %2 return type does not matched with the %2 return type in the %s",
]);

define(1034,"INTERFACE_MEMBER_INCONFORMITY",[
    "实现接口成员(%1)不兼容",
    "The '%s' inconformity with the %s in the '%s'",
]);

define(1035,"INTERFACE_MEMBER_MISSING_PARAMS",[
    "实现接口(%1)中,参数缺失",
    "The '%s' %s params missing with the %s params in the '%s'",
]);

define(1036,"INTERFACE_MEMBER_PARAMS_NOT_MATCHED",[
    "实现接口(%1)中，参数的类型不匹配",
    "The '%s' %s params type not matched with the %s params in the '%s'",
]);

define(1037,"INTERFACE_MEMBER_GENERIC_PARAMS_NUM_INCONSISTENCY",[
    "实现接口(%1)中，泛型的数目不一致",
    "The '%s' %s declare generics number inconsistency in the '%s'",
]);

define(1038,"INTERFACE_MEMBER_GENERIC_NOT_SATISFY_CONSTRAINTS",[
    "实现接口(%1),泛型约束类型不匹配",
    "The '%s' %s generics does not satisfy constraint with the '%s'",
]);

define(1039,"INTERFACE_MEMBER_MODIFIER_NOT_CONSISTENT",[
    "实现接口(%1)中,访问命名空间的修饰符不一致",
    "the '%s' %s modifier is not consistent with the %s modifier in the '%s'",
]);

define(1040,"DECLARE_ALIAS_TYPE_NOT_ASSIGNMENT_VALUE",[
    "声明的别名类型(%s)必须指定一个类型值",
    "Declare '%s' alias type must assignment a type",
]);

define(1041,"MISSING_CONDITION",[
    "缺少条件",
    "Missing condition",
]);

define(1042,"LOOP_MAYBE_INFINITE_EXECUTE",[
    "循环语句体中缺少退出语句，可能会导致无限循环",
    "The absence of an exit statement in the body of a do while statement may result in an infinite loop",
]);

define(1043,"TOKEN_INVALID",[
    "无效的标识符",
    "Token(%s) invalid",
]);

define(1044,"PROPERTY_INITIAL_VALUE_NOT_NUMBER",[
    "属性的初始值必须是数字",
    "Property the '%s' initial value is not a number",
]);

define(1045,"PROPERTY_REDEFINED",[
    "属性(%s)已经存在，不能重复定义",
    "Property the '%s' already exists. cannot redefined",
]);

define(1046,"REFS_VALUE_NOT_OBJECT",[
    "引用的值必须是对象",
    "The refs value of '%s' is not an object",
]);

define(1047,"LOOP_ONLY_SINGLE_VARIABLE",[
    "循环(%s)中只能声明单个变量",
    "Only a single variable declaration is allowed in a '%s' statement",
]);

define(1048,"LOOP_CANNOT_HAVE_INITIAL",[
    "循环(%s)声明的变量不能有初始值",
    "The variable declaration of a '%s' statement cannot have an initial",
]);

define(1049,"REFS_VALUE_MAYBE_NOT_OBJECT",[
    "引用的值可能不是对象值",
    "The refs value of '%s' maybe is not an object",
]);

define(1050,"PARAMETER_OPTION_ONLY_DECLARE_AFTER",[
    "带有初始值的参数(可选参数)只能跟在必填参数的后面",
    "The '%s' parameter with an initial value in method can only be declared after the parameter",
]);

define(1051,"PARAMETER_REST_MUST_AT_END",[
    "剩余参数只能在参数的结尾",
    "The '%s' rest parameter can only appear at the end of the params",
]);

define(1052,"CONSTRUCTOR_NOT_RETURN_VALUE",[
    "构造函数中不需要有返回值",
    "Constructor does not need to return value",
]);

define(1053,"CONSTRUCTOR_FIRST_CALL_SUPER",[
    "构造函数中必须先调用超类方法(super)",
    "Constructor must first call super",
]);

define(1054,"FUN_MUST_HAVE_RETURN_VALUE",[
    "函数声明的类型必须有返回值",
    "A function whose declared type is neither 'void' nor 'any' must return a value",
]);

define(1055,"FUN_ASYNC_MUST_RETURN_PROMISE",[
    "声明为异步的函数必须返专有类型(%s)",
    "The return type of an async function or method must be the '%s' type",
]);

define(1056,"GENERIC_DECLARE_ALREADY_EXISTS",[
    "声明的泛型已经存在",
    "Generic '%s' is already exists",
]);

define(1057,"GENERIC_NAME_CONFLICTS_WITH_TYPE",[
    "声明的泛型与类型名冲突",
    "Generic '%s' conflicts with type name.",
]);

define(1058,"GENERIC_DECLARE_REQUIRED_PARAM_NOT_FOLLOW_OPTIONAL",[
    "声明泛型的参数，不能跟在可选参数的后面",
    "Required type parameters may not follow optional type parameters",
]);

define(1059,"REFS_TO_TYPE_NOT_USED_VALUE",[
    "当前的引用(%s)指向一个类型，不能当作值传递",
    "'%s' only refers to a type, but is being used as a value here.",
]);

define(1060,"REFS_IS_NOT_EXIST",[
    "引用(%s)不存在",
    "'%s' does not exist.",
]);

define(1061,"REFS_IS_NOT_ACCESSIBLE",[
    "引用(%s)不可访问",
    "'%s' is not accessible.",
]);

define(1062,"GENERIC_CANNOT_DECLARE_ON_CONSTRUCTOR",[
    "不能在构造函数上声明泛型",
    "Generic cannot be declared on constructor",
]);

define(1063,"METHOD_NOT_HAVE_OVERRIDE",[
    "类中成员方法(%1)在父类中不存在，不需要标记重写(@Override))注解符",
    "The '%s' %s does not exists in the superclass. remove the '@Override' annotator if not overwrite.",
]);

define(1064,"METHOD_NEED_HAVE_OVERRIDE",[
    "类中成员方法(%1)在父类中存在，需要标记重写(@Override)注解符",
    "the '%s' %s already exists in the superclass. use the '@Override' annotator if need overwrite",
]);

define(1065,"METHOD_GET_ACCESSOR_NOT_PARAM",[
    "获取访问器(%s)不需要声明参数",
    "'%s' getter does not defined param",
]);

define(1066,"METHOD_GET_ACCESSOR_NOT_PARAM",[
    "获取访问器(%s)需要返回值",
    "'%s' getter accessor must have a return value",
]);

define(1067,"METHOD_SET_ACCESSOR_NEED_PARAM",[
    "设置访问器(%s)需要声明一个参数",
    "'%s' setter must have one param",
]);

define(1068,"METHOD_ACCESSOR_TYPE_NOT_MATCHED",[
    "访问器(%s)的接收类型不匹配",
    "'%s' setter and getter parameter types do not match",
]);

define(1069,"NEW_IS_CANNOT_INSTANTIATED",[
    "当前引用(%s)不是一个可被实例化的对象",
    "'%s' is cannot be instantiated.",
]);

define(1070,"NEW_IS_ABSTRACT_CANNOT_INSTANTIATED",[
    "当前引用(%s)是一个抽象类，不能被实例化对象",
    "'%s' is an abstract class. cannot be instantiated.",
]);

define(1071,"REST_TYPE_NOT_MATCHED",[
    "剩余参数只能是一个元组类型",
    "Rest accept type must is tuple type",
]);

define(1072,"RETURN_MUST_FUN_BODY",[
    "返回表达式只能在函数体中",
    "Return expression must in function body",
]);

define(1073,"CONNOT_CONVERT_ARRAY",[
    "当前的引用不能转换为一个数组",
    "The '%s' cannot convert a reference to an array",
]);

define(1074,"CONNOT_CONVERT_OBJECT",[
    "当前的引用不能转换为一个对象",
    "The '%s' cannot convert a reference to an object",
]);

define(1075,"NOT_CALL_SUPER",[
    "调用超类(super)方法需要在子类中",
    "'super' no inherit parent class",
]);

define(1076,"SUPER_ONLY_IN_METHODS_CALLED",[
    "超类方法(super)只能在类方法中调用",
    "'super' can only be called in class methods",
]);

define(1077,"TUPLE_REST_MUST_FOLLOW_END",[
    "元组类型中声明的剩余类型只能出现在元素的结尾",
    "Tuple type rest parameter must follow the end",
]);

define(1078,"TYPE_DECLARE_ALREADY_EXISTS",[
    "声明的类型(%s)已经存在",
    "Declare type '%s' already exists",
]);

define(1079,"MISSING_TYPE_EXPRESSION",[
    "缺少类型引用",
    "Missing type expression",
]);

define(1080,"PROPERTY_NOT_EXISTS",[
    "属性名(%s)不存在",
    "Property the '%s' is not exists",
]);

define(1081,"SPREAD_OBJECT_EXPRES_MUST_HAVE_INITIAL",[
    "展开对象表达式必须设置一个初始值",
    "Spread object expression, must have initial",
]);

define(1082,"PROPERTY_WITH_PARENT_MEMBER_CONFLICTS",[
    "当前属性(%s)与父类中的成员有冲突",
    "Property '%s' conflicts with a member of the parent class",
]);

define(1083,"TYPE_IS_NOT_EXISTS",[
    "引用的类型不存在",
    "Type '%s' is not exists",
]);

define(1084,"REQUIRED_PARAM_NOT_FOLLOW_OPTIONAL",[
    "声明的参数，不能跟在可选参数的后面",
    "Required parameters may not follow optional type parameters",
]);

define(1085,"ERROR",[
    "编译错误(%s)",
    "%s",
]);

define(1086,"SPECIFIES_TYPE_ARRAY_ELEMENT_NOT_SPECIFIED_INDEX_TYPE",[
    "指定类型为(%s)的数组元素，不能在数组索引位置指定类型",
    "Specifies an array element of %s type. the type cannot be specified at the array index",
]);

define(1087,"UPDATE_EXPRESSION_MUST_IS_NUMERIC",[
    "更新表达式(%s)的引用类型必须是一个数字类型",
    "The reference type of the update expression '%s' must be a numeric type",
]);

define(1088,"METHOD_NOT_HAVE_OVERRIDE",[
    "需要重写的方法(%s)参数数目不一致",
    "Inconsistent number of the '%s' method arguments to override",
]);

define(1089,"METHOD_NOT_HAVE_OVERRIDE",[
    "需要重写的存储器(%s)参数数目不一致",
    "Inconsistent number of the '%s' setter arguments to override",
]);

define(1090,"INTERFACE_MEMBER_INCONSISTENT_NUMBER_PARAMS",[
    "实现接口(%s)中的参数不兼容",
    "Implemented interface parameters is not compatible in the '%s' method",
]);

define(1091,"FRAGMENT_EXPRESSION_ERROR",[
    "片段表达式只能出现在结尾",
    "fragment expressions can only appear at the end",
]);

define(1092,"ANNOTATIONS_RUNTIME_METHOD_PARAM_INVALID",[
    "注解Runtime方法参数值只能是'server,client'",
    "Annotations runtime method parameters can only is 'server' or 'client'",
]);

define(1093,"ANNOTATIONS_LOCATION_INVALID",[
    "注解方法在此位置未生效",
    "Annotation method not in effect at this location",
]);

define(1094,"IMPORT_DECLAREATION_STATEMENT_INVALID",[
    "在此处声明的导入语无效",
    "The import declared here is invalid",
]);

define(1095,"LOAD_TYPE_DESCRIPTION_FILE_INVALID",[
    "指定加载的类型描述文件无效",
    "The type description file specified to load is invalid",
]);

module.exports = Diagnostic;