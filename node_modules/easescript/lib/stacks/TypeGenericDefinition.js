const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const ClassGenericType = require("../types/ClassGenericType");
const keySymbol = Symbol("key");
class TypeGenericDefinition extends Stack {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isTypeGenericDefinition= true;
        this.valueType = Utils.createStack(compilation,node.value, scope, node, this);
        this.elements = node.typeElements.map( item=>{
            return Utils.createStack(compilation,item,scope,node,this);
        });
        this.isThisType = this.valueType && this.valueType.value() === "this";
        this[keySymbol]={};
    }
    freeze(){
        super.freeze();
        super.freeze( this.elements );
        this.valueType.freeze();
        this.elements.forEach( stack=>stack.freeze() );
    }
    definition(){
       const type = this.type();
       const identifier = this.valueType.value();
       if( !type )return null;
       return {
           kind:this.kind,
           comments:this.comments,
           identifier:identifier,
           expre:`(type) ${type.toString(true)}`,
           location:this.valueType.getLocation(),
           file:this.compilation.file,
           context:this
       };
    }
    error(code,...args){
        this.valueType.error(code,...args);
    }
    warn(code,...args){
        this.valueType.warn(code,...args);
    }
    description(){
        return this;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    type(){
        if( !this[keySymbol]._type ){
            const value = this.valueType.value();
            const desc = this.isThisType ? this.module : (this.getModuleById( value ) || this.scope.define( value ));
            if( desc ){
                const type = desc.type();
                if( type ){
                    const classType = this.getGlobalTypeById("Class");
                    const isClass = type === classType || (type.extends && type.extends[0]===classType);
                    this[keySymbol]._type = new ClassGenericType(
                        this.elements.map( item=>item.type() ),
                        isClass ? classType : type,
                        isClass,
                        this
                    );
                }
            }
        }
        return this[keySymbol]._type;
    }

    getGenericTypes(){
        if( this[keySymbol]._relatedGenericTypes ){
            return this[keySymbol]._relatedGenericTypes;
        }
        const type = this.type();
        const originType = type && type.extends[0];
        if( !(originType && originType.isModule) )return null;
        const declareGenerics = originType.getModuleGenerics();
        const relatedTypes = new Map();
        const assigns = type.types;
        declareGenerics.forEach( (item,index)=>{
            const type = item.type();
            if( assigns[index] ){
                relatedTypes.set( type, assigns[index].type() );
            }else if( type.assignType ){
                relatedTypes.set( type, type.assignType );
            }
        });
        this[keySymbol]._relatedGenericTypes = relatedTypes;
        return relatedTypes;
    }

    parser(){
        const type = this.type();
        if( !type ){
            this.valueType.error(1083,this.value());
        }else{
            const baseType = type.extends[0];
            if( baseType ){
                const stack = this.compilation.getStackByModule( baseType );
                const declareGenerics = stack && stack.genericity && stack.genericity.elements || [];
                const isClass = type.isClassType;
                const requires = declareGenerics.filter( item=>{
                    return !item.isGenericTypeAssignmentDeclaration;
                });
                if( requires.length > this.elements.length || this.elements.length > declareGenerics.length ){
                    if( requires.length === declareGenerics.length ){
                        this.valueType.error(1030,baseType.toString(),requires.length);
                    }else{
                        this.valueType.error(1031,baseType.toString(),requires.length,declareGenerics.length);
                    }
                }
                if( declareGenerics.length > 0 ){
                    this.elements.forEach( (item,index)=>{
                        item.parser( isClass );
                        const declareType = declareGenerics[index].type();
                        if( declareType && !declareType.isGenericType && !declareType.check(item) ){
                            item.error(1009,item.type().toString(),declareType.toString())
                        }
                    });
                }
            }
        }
    }
    checker(){
        this.elements.forEach(item=>item.checker());
    }
    value(){
        return this.valueType.value()
    }
    raw(){
        return this.valueType.raw();
    }
}

module.exports = TypeGenericDefinition;