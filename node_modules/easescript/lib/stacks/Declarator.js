const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
class Declarator extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isDeclarator= true;
        this.acceptType = Utils.createStack( compilation, node.acceptType, scope, node ,this);
        if( parentStack && (parentStack.isFunctionExpression || parentStack.isTypeFunctionDefinition) ){
            this.question = !!node.question;
            this.isParamDeclarator = true;
        }
        this.assignValue = null;
        this.assignItems = new Set();
        this.useRefItems = new Set();
        this._kind = "var";
    }

    addUseRef( stack ){
       this.useRefItems.add(stack);
    }

    freeze( target ){
        super.freeze(target);
        super.freeze( this.assignItems );
        super.freeze( this.useRefItems );
        this.acceptType && this.acceptType.freeze();
    }

    definition(){
        if( this.parentStack.isFunctionExpression){
            const type = this.type().toString();
            const identifier = this.value();
            const context = this;
            return {
                kind:'parameter',
                comments:this.comments,
                identifier:identifier,
                expre:`(parameter) ${identifier}:${type}`,
                location:this.getLocation(),
                file:this.compilation.file,
                context
            };
        }else if( this.parentStack.isArrayPattern ){
            const identifier = this.value();
            const desc = this.description();
            const context = desc;
            const expre = desc.isFunctionExpression ? `${this.kind} ${identifier}:()=>${desc.type().toString()}` : `${this.kind} ${identifier}:${this.type().toString()}`;
            return {
                kind:this.kind,
                comments:this.comments,
                identifier:identifier,
                expre:expre,
                location:this.getLocation(),
                file:this.compilation.file,
                context
            };
        }
        return null;
    }

    set kind(value){
       this._kind=value;
    }

    get kind(){
        return this._kind;
    }

    reference( called ){
        if( Utils.isFunction(this.assignValue) ){
            return this.assignValue;
        }
        return this.assignValue && this.assignValue.isStack ? this.assignValue.reference( called ) : this;
    }

    referenceItems( called ){
        let items = [];
        this.assignItems.forEach( item=>{
            if( !called && Utils.isFunction(item) ){
                items.push(item)
            }else{
                items=items.concat( item.referenceItems( called ) );
            }
        });
        return items.length > 0 ? items : [this];
    }

    description(){
        return this;
    }

    getRelateParamDescription(stack){
        if( !stack || !(stack.isCallExpression || stack.isNewExpression) )return null;
        let desc = stack.description();
        if( desc && stack.isNewExpression ){
            desc = desc.type();
            if( desc.isAnyType ){
                return null;
            }
            const methodConstructor = Utils.isClassType(desc) && desc.getConstructMethod();
            return methodConstructor ? methodConstructor.params : null;
        }
        if( !desc )return null;
        if( Utils.isTypeModule(desc) ){
            this.compilation.addDependency(desc,this.module );
        }
        if( Utils.isClassType(desc) && desc.callable){
            desc = desc.callable;
        }
        if( desc.isProperty && !desc.hasAssignmentPattern){
            desc = desc.description();
        }
        if( desc.isDeclarator ){
            desc = desc.type();
        }
        return desc.params || null;
    }

    getRelateParamType(){
        if( !this.parentStack.isFunctionExpression ){
            return null;
        }
        const stack= this.parentStack.parentStack;
        const declareParams = this.getRelateParamDescription(stack);
        if( !declareParams )return null;
        const paramIndex = (stack.arguments||[]).indexOf( this.parentStack );
        const declareParamType = declareParams[paramIndex] && declareParams[paramIndex].type();
        if( declareParamType && declareParamType.isFunctionType ){
            const index = this.parentStack.params.indexOf( this );
            return declareParamType.params[ index ]  && declareParamType.params[ index ].type();
        }
        return null;
    }

    getGenericTypes(){
        if( !this.parentStack.isFunctionExpression){
            return flag ? paramType : null;
        }
        const stack= this.parentStack.parentStack;
        return stack && stack.getGenericTypes();
    }

    type(){
        if( this.acceptType  ){
            return this.acceptType.type();
        }
        if( this._type ){
            return this._type;
        }
        const type = this.getRelateParamType();
        if( type ){
            return this._type = type.clone( this.inference() );
        }

        let assignValue = this.assignValue
        if( this.assignItems.size > 1 ){
            const assignItems = Array.from( this.assignItems.values() );
            const first = assignItems[0];
            const arrayType = this.getGlobalTypeById("Array");
            if( first.type().inherit === arrayType ){
                return this._type = first.type();
            }
            const scope = first.isFunctionExpression ? first.parentStack.scope : first.scope;
            assignValue = assignItems.reverse().find( item=>{
                const s = item.isFunctionExpression ? item.parentStack.scope : item.scope;
                return scope === s;
            });
        }

        const description = assignValue;
        if( description ){
            this._type = description.type();
        }
        if( !this._type ){
            this._type = this.getGlobalTypeById("any");
        }
        return this._type;
    }

    checker(){
        this.acceptType && this.acceptType.checker();
        if( this.module && this.module.id === this.value() ){
            this.error(1008,this.value());
        }
    }

    parser(){
        if( super.parser() ){
            this.acceptType && this.acceptType.parser(); 
            return true;
        }
        return false;
    }

    assignment( value, stack=null ){
        if( this.assignValue !== value  ){
            let acceptType = this.acceptType && this.acceptType.type();
            if( !acceptType && this.assignValue ){
                acceptType = this.assignValue.type();
            }
            if( acceptType && !acceptType.check( value ) ){
                (stack||this).error(1009, value.type().toString(), acceptType.toString());
            }
            this.assignItems.add( value );
            this.assignValue = value;
            if( value && value.isStack ){
                this.setRefBeUsed( value.description() );
            }
        }
    }
}

module.exports = Declarator;