const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const GenericType = require("../types/GenericType");
class GenericTypeDeclaration extends Stack {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isGenericTypeDeclaration= true;
        this.valueType = Utils.createStack(compilation,node.value, scope, node, this);
        this.extends = Utils.createStack(compilation,node.extends, scope, node, this);
    }
    freeze(){
        super.freeze(this);
        super.freeze(this.valueType);
        super.freeze(this.extends);
    }
    definition(){
       const type = this.type();
       const identifier = this.valueType.value();
       return {
           kind:this.kind,
           comments:this.comments,
           identifier:identifier,
           expre:`(Type) ${type.toString()}`,
           location:this.valueType.getLocation(),
           file:this.compilation.file,
           context:this
       };
    }
    error(code,...args){
        this.valueType.error(code,...args);
    }
    warn(code,...args){
        this.valueType.warn(code,...args);
    }
    description(){
        return this;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    type(){
        if( !this._type ){
            const isFunGeneric = !!(this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isFunctionExpression);
            this._type = new GenericType( this, this.extends ? this.extends.type() : null, null, isFunGeneric );
        }
        return this._type;
    }
    parser(){
        this.extends && this.extends.parser();
    }
    checker(){
        this.extends && this.extends.checker();
    }
    value(){
        return this.valueType.value(); 
    }
    raw(){
        return this.valueType.raw();
    }
}

module.exports = GenericTypeDeclaration;