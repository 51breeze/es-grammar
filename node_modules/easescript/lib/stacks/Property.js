const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
class Property extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isProperty= true;
        this.hasAssignmentPattern = false;
        this.assignValue = null;
        this._assignItems = new Set();
        this.useRefItems = new Set();
        if( node && parentStack ){
            this.key = Utils.createStack( compilation, node.key,scope, node,this );
            this.init = Utils.createStack( compilation, node.value,scope, node,this );
            this.acceptType = Utils.createStack( compilation, node.acceptType,scope, node,this );
            if( this.init.isAssignmentPattern ){
                this.hasAssignmentPattern = true;
                this.init.acceptType = this.acceptType;
            }
            if( !(parentStack.isObjectPattern && node.key===node.value) ){
                this.assignValue = this.init;
                this._assignItems.add(this.init);
            }
            this._kind = node.kind;
            this.computed = !!node.computed;
        }
    }

    addUseRef( stack ){
        this.useRefItems.add(stack);
    }

    freeze(){
        super.freeze();
        this.key && this.key.freeze();
        this.init && this.init.freeze();
        this.acceptType && this.acceptType.freeze();
    }

    definition(){
        if( this.parentStack.isObjectPattern ){
            const type = this.type().toString();
            const identifier = this.key.value();
            const context = this.parentStack.parentStack.parentStack;
            return {
                kind:this.kind,
                comments:context.comments,
                identifier:identifier,
                expre:`${this.kind} ${identifier}:${type}`,
                location:this.key.getLocation(),
                file:this.compilation.file,
                context
            };
        }else if(this.parentStack.isObjectExpression && !this.hasAssignmentPattern && this.init ){
            // if( this.computed ){
            //     const desc = this.key.description();
            //     if( desc ){
            //         return desc.definition();
            //     }
            // }
            // const stack = this.description();
            // if( stack ){
            //     const def = stack.definition();
            //     if( def )return def;
            // }
        }
        const context = this;
        const identifier = this.value();
        const type = this.type().toString();
        return {
            kind:"property",
            comments:context.comments,
            identifier:identifier,
            expre:`(property) ${identifier}: ${type}`,
            location:this.key.getLocation(),
            file:this.compilation.file,
            context
        };
    }

    set kind( value ){
        if( this.hasAssignmentPattern ){
            this.init.kind = value;
        }else{
            this._kind = value;
        }
    }

    get kind(){
        if( this.hasAssignmentPattern ){
            return this.init.kind;
        }else{
            return this._kind;
        }
    }

    value(){
        return this.key.value();
    }

    reference(){
        if( this.hasAssignmentPattern ){
            return this.init.reference();
        }
        return this.assignValue ? this.assignValue.reference() : null;
    }

    referenceItems(){
        if( this.hasAssignmentPattern ){
            return this.init.referenceItems();
        }
        let items = [];
        this.assignItems.forEach( item=>{
            items=items.concat( item.referenceItems() );
        });
        return items;
    }

    get assignItems(){
        if( this.hasAssignmentPattern ){
            return this.init.assignItems;
        }
        return this._assignItems;
    }

    assignment(value){
        if( this.parentStack.isObjectPattern && this.hasAssignmentPattern){
            this.init.assignment(value);
        }else if(this.assignValue !== value){
            let acceptType = this.acceptType ? this.acceptType.type() : null;
            if( !acceptType && this.assignValue ){
                acceptType = this.assignValue.type();
            }
            if( acceptType && !acceptType.check( value ) ){
                value.error(1009,value.type().toString(),acceptType.toString());
            }
            this.assignValue = value;
            this._assignItems.add( value );
            if( value && value.isStack ){
                this.setRefBeUsed( value.description() );
            }
        }
    }

    type(){
        if( this.acceptType ){
            return this.acceptType.type();
        }
        if( this.assignValue ){
            return this.assignValue.type();
        }
        return this.getGlobalTypeById("any");
    }

    description(){
        if( this.__description !== void 0){
            return this.__description;
        }
        let desc = null;
        if( this.assignValue ){
            desc= this.assignValue.description();
            const stack = this.getParentStack( stack=>!!(
                stack.isVariableDeclarator || 
                stack.isBlockStatement || 
                stack.isAssignmentExpression ||
                stack.isAssignmentPattern ));
            if( stack && this.init && (stack.isAssignmentExpression || stack.isVariableDeclarator || stack.isAssignmentPattern ) ){
                if( stack.value() === this.init.value() ){
                    const assignValue = stack.isVariableDeclarator ? stack.init :  stack.right;
                    if( desc.assignItems.size > 1 ){
                        const items = Array.from( desc.assignItems );
                        const index = items.lastIndexOf( assignValue );
                        if( index > 0 ){
                            desc = items[ index-1 ];
                        }
                    }
                }
            }
        }
        return this.__description = desc;
    }

    parser(){
        this.acceptType && this.acceptType.parser();
        if( this.init ){
            this.init.parser();
            this.init.setRefBeUsed();
        }

        const name  = this.value();
        if( !this.parentStack.isObjectPattern ){
            if( this.computed ){
                const refs = this.scope.define( name );
                if( this.key.isIdentifier && !refs  ){
                    this.error(1013,name);
                }
                this.setRefBeUsed( refs );
            }
            return;
        };
        //spread object or array
        const desc  =  this.scope.define( name );
        const target = this.parentStack.parentStack.init;
        if( !target )return;
        if( target.isObjectExpression || target.isArrayExpression ){
            const init = target.attribute( name );
            if( !init ){
                this.error(1080, name);
            }
            desc && desc.assignment( init );
        }else{
            let type = target.type();
            if( type.isAnyType ){
                return;
            }
            if( type && (type.isLiteralObjectType || type.isLiteralArrayType || type.isGenericType) ){
                const propertyValue = type.attribute( name );
                if( !propertyValue ){
                    if( !this.init.isAssignmentPattern ){
                        this.error(1080, name);
                    }
                }else{ 
                    desc && desc.assignment( propertyValue );
                }
            }
        }
    }

    checker(){
        this.acceptType && this.acceptType.checker();
        this.init && this.init.checker();
    }

    error(code, ...args){
        this.key.error(code,...args);
    }
    warn(code, ...args){
        this.key.warn(code, ...args);
    }
}

module.exports = Property;