const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const UnionType = require("../types/UnionType");
const Declarator = require("./Declarator");
class ArrayPattern extends Stack {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isArrayPattern=true;
        this.elements = node.elements.map( item=>{
            let stack = null;
            if(item.type ==="Identifier"){
               stack = new Declarator(compilation, item, scope, node,this);
               const context = parentStack.parentStack.kind ==="var" ? 'function' : 'block';
               const name = stack.value();
               if( scope.isDefine( name , context ) ){
                   this.error(1007, name);
               }
               scope.define( name, stack );
            }else{
               stack = Utils.createStack( compilation, item, scope, node,this);
            }
            return stack;
        });
    }
    freeze(){
        super.freeze(this);
        super.freeze(this.elements);
        this.elements.forEach(stack=>stack.freeze());
    }
    definition(){
        return null;
    }

    setKind(value){
        this.elements.forEach( item=>{
            item.kind=value;
        });
    }

    parser(){
        const init = this.parentStack.init;
        const is   = init.isArrayExpression;
        const refs = init.type();
        const arrayType = this.getGlobalTypeById("array");
        const iteratorType = this.getGlobalTypeById("Iterator");
        if( !(arrayType.check( refs ) || iteratorType.check( refs ) ) ){
            init.error(1012, init.raw(), refs.toString());
        }
        const getInitType=()=>{
            if( refs.isTupleType ){
                const elements = Utils.toTypeUniqueArray(refs.elements);
                if( elements.length ===1 ){
                    return elements[0].type();
                }
                return new UnionType(elements, refs.target);
            }else if( refs.isUnionType ){
                return refs;
            }
            return null
        }
        this.elements.forEach( (item,index)=>{
            item.parser();
            const desc = item.description();
            const defaultValue = item.isAssignmentPattern ? true : false;
            if( desc ){
                if( is ){
                    const value = init.attribute( index );
                    if(!defaultValue && !value ){
                        item.error(1014,init.raw(),index);
                    }
                    if( value ){
                        desc.assignment(value);
                    }else if(item.right){
                        desc.assignment(item.right);
                    }
                }else{
                    let value = refs && (refs.isLiteralArrayType || refs.isTupleType ) ? refs.attribute( index ) : null;
                    if( !value ){
                        value = getInitType();
                    }
                    if( value ){
                        desc.assignment(value);
                    }else if(item.right){
                        desc.assignment(item.right);
                    }
                }
            }
        });
    }

    checker(){
        this.elements.forEach( item=>item.checker() );
    }

    value(){
       return this.elements.map(item=>{
           return item.value()
       }).join(",")
    }
}

module.exports = ArrayPattern;