const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const InstanceofType = require("../types/InstanceofType");
const Type = require("../types/Type");
const keySymbol = Symbol("key");
class TypeDefinition extends Stack {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isTypeDefinition= true;
        this.valueType = Utils.createStack(compilation,node.value, scope, node, this);
        this.isThisType = this.valueType.value() === "this";
        this[keySymbol] = this;
    }
    freeze(){
        super.freeze();
        this.valueType.freeze();
    }
    definition(called){
        const type = this.type();
        const identifier = this.valueType.value();
        const pStack = this.parentStack;
        if( pStack.isTypeTupleDefinition || pStack.isTypeTupleRestDefinition || pStack.isTypeTupleUnionDefinition || pStack.isTypeGenericDefinition){
            return pStack.definition(called);
        }
        if( !type ){
            return null;
        }
        return {
            kind:this.kind,
            comments:this.comments,
            identifier:identifier,
            expre:`(type) ${type.toString()}`,
            location:this.valueType.getLocation(),
            file:this.compilation.file,
            context:this
        };
    }
    error(code,...args){
        this.valueType.error(code,...args);
    }
    warn(code,...args){
        this.valueType.warn(code,...args);
    }
    description(){
        return this;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    type(){
        if( !this[keySymbol]._type ){
            let value = this.valueType.value();
            if( this.valueType.isLiteral ){
                const type = this.valueType.type();
                type.target = this;
                return this[keySymbol]._type = type;
            }
            let type = this.isThisType ? new InstanceofType(this.module, this) : this.getModuleById( value );
            if( !type ){
                type =  this.scope.define( value );
                if( type && (type.isGenericTypeDeclaration || type.isGenericTypeAssignmentDeclaration) ){
                    type = type.type();
                }else{
                    type = null;
                }
            }
            this[keySymbol]._type = type;
        }
        return this[keySymbol]._type;
    }
    checker(){
        this.valueType.checker();
    }
    parser( isClassGenerics ){
        let type = this.valueType.description();
        if( !type ){
            this.valueType.error(1083, this.valueType.value() );
        }else if(!isClassGenerics){
            type = type.type();
            const stackModule = this.compilation.getStackByModule( type.isAliasType ? type.extends[0] : type );
            if( stackModule && stackModule.genericity && stackModule.genericity.isGenericDeclaration ){
                const requires = stackModule.genericity.elements.filter( item=>!item.isGenericTypeAssignmentDeclaration )
                const len = requires.length;
                if( len > 0 ){
                    this.valueType.error(1030,type.toString(),len);
                }
            }
            if( !type || !(type instanceof Type) ){
                this.valueType.error(1083,this.value());
            }
            if( this.module ){
                type = Utils.getOriginType(type);
                if( Utils.isTypeModule(type) ){
                    this.compilation.addDependency(type, this.module);
                }
            }
        }
    }
    value(){
        return this.valueType.value();
    }
    raw(){
        return this.valueType.raw();
    }
}

module.exports = TypeDefinition;