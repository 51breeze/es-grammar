const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const EnumType = require("../types/EnumType");
class EnumDeclaration extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isEnumDeclaration= true;
        this.isDeclarator = true;
        this.key = Utils.createStack(compilation,node.key,scope,node,this);
        this.inherit = Utils.createStack(compilation,node.extends,scope,node,this);
        this.increment =0;
        this.mapProperties = new Map();
        if( parentStack.isPackageDeclaration ){
            this.modifier = Utils.createStack(compilation,node.modifier,scope,node);
            const module = this.module = compilation.createModule(this.namespace, this.key.value());
            this.imports = [];
            module.id = this.key.value();
            module.comments = this.comments;
            module.isEnum = true;
            module.increment = this.increment;
            compilation.addModuleStack(module,this);
        }else{
            this.properties = node.properties.map( (item,index)=>{
                const stack = Utils.createStack(compilation,item,scope,item,this);
                const lastValue = stack.init.value();
                if( !stack.key.isIdentifier ){
                    stack.error(1043,stack.raw());
                }
                if( typeof lastValue === "number" ){
                    this.increment = lastValue + 1;
                }else{
                    stack.error(1044,stack.raw());
                }
                if( this.mapProperties.has( stack.value() ) ){
                    stack.error(1045,stack.raw());
                }
                this.mapProperties.set(stack.value(), stack);
                return stack;
            });
            scope.define(this.value(), this);
        }
    }

    freeze(){
        super.freeze(this);
        super.freeze(this.properties);
        super.freeze(this.mapProperties);
        if( this.parentStack.isPackageDeclaration ){
            super.freeze(this.id);
            super.freeze(this.module);
            (this.properties||[]).forEach(stack=>stack.freeze());
        }
    }

    createCompleted(){
        const compilation = this.compilation;
        const module = this.module;
        this.imports.forEach( stack=>{
            const module = compilation.getModuleById( stack.value() );
            if( module ){
                if( this.checkDepend(this.module,module) ){
                    stack.error(1024,stack.value())
                }
                const nameId = stack.alias ? stack.alias.value() :  module.id;
                if( !this.module.addImport(nameId, module, module.id != nameId ) ){
                    stack.error(1025,nameId)
                } 
            }else{
                stack.error(1026,stack.value())
            }
        });
        if( this.inherit ){
            const inherit = this.getModuleById( this.inherit.value() );
            if( !inherit ){
                this.inherit.error(1027,this.inherit.raw());
            }
            module.extends = inherit;
            this.increment = inherit.increment;
        }else {
            module.extends = this.getModuleById("Object")
        }
        this.properties = this.node.properties.map( (item,index)=>{
            const stack = Utils.createStack(compilation,item,this.scope,item,this);
            const lastValue = stack.init.value();
            if( !stack.key.isIdentifier ){
                stack.error(1043,stack.raw());
            }
            if( typeof lastValue === "number" ){
                this.increment = lastValue + 1;
            }else{
                stack.error(1044,stack.raw());
            }
            if( this.mapProperties.has( stack.value() ) ){
                stack.error(1045,stack.raw());
            }
            this.mapProperties.set(stack.value(), stack);
            module.addMember(stack.value(), stack, true);
            return stack;
        });
        module.increment = this.increment;
    }

    assignment( value, stack=null ){
        (stack||this).error(1015,this.raw());
    }

    definition(){
        const properties = this.properties.map( item=>{
            return `${item.value()}=${item.init.value()}`;
        })
        const expre = `enum ${this.value()}={${properties.join(",")}}`;
        return {
            kind:"enum",
            comments:this.comments,
            identifier:this.value(),
            expre:expre,
            location:this.key.getLocation(),
            file:this.compilation.file,
            context:this
        };
    }
    attribute(name){
        return this.mapProperties.get(name) || null;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    description(){
        return this;
    }
    checker(){
        this.inherit && this.inherit.checker();
        this.properties.forEach( item=>item.checker() ); 
    }
    type(){
        if( this.parentStack.isPackageDeclaration ){
            return this.module;
        }
        return this._type || (this._type = new EnumType(this.getModuleById("Object"),this));
    }
    parser(){
        this.inherit && this.inherit.parser();
        this.properties.forEach( item=>item.parser());
    }
    value(){
        return this.key.value();
    }
}

module.exports = EnumDeclaration;