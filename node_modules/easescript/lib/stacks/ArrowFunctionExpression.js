const FunctionExpression = require("./FunctionExpression");
class ArrowFunctionExpression extends FunctionExpression{
    constructor(compilation,node,scope,parentNode,parentStack){
         super(compilation,node,scope,parentNode,parentStack);
         this.isArrowFunctionExpression=true;
         this.scope.isArrow = true; 
         this.scope.isExpression = !!node.expression;
    }
    type(called){
        if( !called ){
            return this.getFunType();
        }
        let type = this.returnType;
        if( type ){
            return type.type();
        }
        if( this.node.expression ){
            const type = this.body.type();
            return type;
        }
        return super.type(called);
    }

    checker(){
        super.checker();
        if( this.scope.isExpression ){
            let acceptType = this.returnType;
            if( acceptType && !acceptType.check(this.body) ){
                this.body.error(1002,this.body.type().toString(),acceptType.toString());
            }
        }
    }

    reference(){
        if(this.scope.isExpression){
            return this.body;
        }
        return super.reference();
    }
    referenceItems(){
        if(this.scope.isExpression){
            return [this.body];
        }
        return super.referenceItems();
    }
    definition(called,inference){
        const type = this.type(true).clone(inference).toString();
        const context = this;
        const params  = this.params.map( item=>{
            const name = item.value();
            const type = item.type(true).clone(inference);
            const rest = item.isRestElement ? '...' : '';
            if( item.question ){
                return `${rest}${name}?:${type.toString()}`
            }
            if( item.isAssignmentPattern && item.right ){
                const initial = item.right.value();
                return `${rest}${name}:${type.toString()}=${initial}`;
            }
            return `${rest}${name}:${type.toString()}`
        });
        return {
            kind:"function",
            comments:context.comments,
            expre:`(${params.join(", ")})=>${type}`,
            location:token.getLocation(),
            file:this.compilation.file,
            context
        };
    }
}

module.exports = ArrowFunctionExpression;