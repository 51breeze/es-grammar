const Utils = require("../core/Utils");
const FunctionExpression = require("./FunctionExpression");
class FunctionDeclaration extends FunctionExpression{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isFunctionDeclaration= true;
        this.key = Utils.createStack(compilation,node.id,scope,node,this);
        scope.define( this.key.value(), this );
        if( node.type==="FunctionDeclaration" ){
            this.scope.define("this", this.getGlobalTypeById("Object") );
        }
        this.useRefItems = new Set();
    }
    
    addUseRef( stack ){
        this.useRefItems.add(stack);
    }

    freeze(){
        super.freeze();
        this.key.freeze();
        Object.freeze( this.useRefItems );
    }
    definition(called , inference){
        const type = this.type(true).clone(inference).toString();
        const identifier = this.key.value();
        const context = this;
        const params  = this.params.map( item=>{
            const name = item.value();
            const type = item.type(true).clone(inference);
            const rest = item.isRestElement ? '...' : '';
            if( item.question ){
                return `${rest}${name}?:${type.toString()}`
            }
            if( item.isAssignmentPattern && item.right ){
                const initial = item.right.value();
                return `${rest}${name}:${type.toString()}=${initial}`;
            }
            return `${rest}${name}:${type.toString()}`
        });
        return {
            kind:"function",
            comments:context.comments,
            identifier:identifier,
            expre:`function ${identifier}(${params.join(", ")}): ${type}`,
            location:this.key.getLocation(),
            file:this.compilation.file,
            context
        };
    }
}

module.exports = FunctionDeclaration;