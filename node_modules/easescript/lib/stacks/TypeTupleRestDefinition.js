const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const TupleType = require("../types/TupleType");
const keySymbol = Symbol("key");
class TypeTupleRestDefinition extends Stack {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isTypeTupleRestDefinition= true;
        this.valueType = Utils.createStack(compilation,node.value, scope, node, this);
        this[keySymbol]={}
    }
    freeze(){
        super.freeze();
        this.valueType.freeze();
    }
    definition(){
       const type = this.type();
       if( type.isModule ){
           return type.definition();
       }
       const identifier = this.valueType.value();
       return {
           kind:this.kind,
           comments:this.comments,
           identifier:identifier,
           expre:`(type) ${type.toString()}`,
           location:this.valueType.getLocation(),
           file:this.compilation.file,
           context:this
       };
    }
    error(code,...args){
        this.valueType.error(code,...args);
    }
    warn(code,...args){
        this.valueType.warn(code,...args);
    }
    description(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    type(){
        if( !this[keySymbol]._type ){
            this[keySymbol]._type = new TupleType(this.getGlobalTypeById("array"), this.valueType.type(), this, true);
        }
        return this[keySymbol]._type;
    }

    checker(){
        this.valueType.checker();
    }

    parser(){
        this.valueType.parser();
    }

    value(){
        return this.valueType.value();
    }

    raw(){
        return  `...`+this.valueType.raw()
    }
}

module.exports = TypeTupleRestDefinition;