const Stack = require("../core/Stack");
const keySymbol = Symbol("key");
class Identifier extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isIdentifier= true;
        this[keySymbol]={};
    }
    definition(called){
        const context = this.description();
        if( context && context !== this ){
            const pStack = this.parentStack;
            if( (pStack.isCallExpression ||  pStack.isNewExpression ) && pStack.callee === this){
                return pStack.definition(called);
            }
            if( pStack.isMemberExpression  ){
                if( pStack.parentStack.isImportDeclaration || pStack.property === this ){
                    return pStack.definition(called);
                }
            }
            if(pStack.isTypeDefinition || pStack.isTypeGenericDefinition ){
                return pStack.definition(called);
            }
            const def = context.definition(called);
            if( def )return def;
        }
        return this.parentStack ? this.parentStack.definition(called) : null;
    }
    completion(){
        return null;
    }
    reference(called){
        const value = this.value();
        const description = this.scope.define( value );
        if(description && description !== this && description instanceof Stack ){
            return description.reference(called);
        }
        return this;
    }

    referenceItems(called){
        const value = this.value();
        const description = this.scope.define( value );
        if(description && description !== this && description instanceof Stack ){
            return description.referenceItems(called);
        }
        return [this];
    }

    description(){
        const value = this.value();
        return this.scope.define( value ) || this.getModuleById( value );
    }

    parser(){
        if( super.parser() === false )return false;
        const description = this.description();
        if( !description ){
            this.error(1013,this.value());
        }else if( description.isAliasType || description.isGenericTypeDeclaration ){
            const parent = this.parentStack;
            if( !parent.isTypeTransformExpression && !(parent.isTypeDefinition || 
                parent.isTypeTupleRestDefinition || 
                parent.isTypeTupleDefinition || 
                parent.isGenericTypeDeclaration || 
                parent.isGenericDeclaration || 
                parent.isTypeObjectDefinition || 
                parent.isTypeObjectPropertyDefinition || 
                parent.isTypeFunctionDefinition || 
                parent.isTypeUnionDefinition) ){
                this.error(1059,this.value());
            }
        }else if( description.isStack ){
            description.parser();
        }
    }

    type(){
        if( this[keySymbol]._type ){
            return this[keySymbol]._type;
        }
        const description = this.description();
        if( !description ){
           return this.getGlobalTypeById("any");
        }else if( description && description.isNamespace ){
            return description;
        }
        return this[keySymbol]._type = description ? description.type() : null;
    }

    value(){
        return this.node.name;
    }

    raw(){
        return this.node.name;
    }
}

module.exports = Identifier;