const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const Namespace = require("../core/Namespace");
const CompilationClass = require("../core/Compilation");
class Program extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isProgram= true;
        this.externals = [];
        this.namespace = Namespace.dataset;
        this.annotations=[];
        this.metatypes=[];
        this.body = [];
        const annotations = [];
        const metatypes = [];
        const imports = [];
        node.body.forEach( item=>{
            const stack = Utils.createStack(compilation, item, scope, node, this);
            if( stack ){
                if( stack.isMetatypeDeclaration ){
                    if(stack.name.toLowerCase() ==='runtime'){
                        this.metatypes.push(stack);
                    }else{
                        metatypes.push(stack);
                    }
                }else if( stack.isAnnotationDeclaration ){
                    if(stack.name.toLowerCase() ==='runtime'){
                        this.annotations.push(stack);
                    }else{
                        annotations.push(stack);
                    }
                }else if(stack.isImportDeclaration ){
                    imports.push( stack );
                }
                else if( stack.isPackageDeclaration || 
                    stack.isClassDeclaration   || 
                    stack.isDeclaratorDeclaration || 
                    stack.isEnumDeclaration      || 
                    stack.isInterfaceDeclaration ||
                    stack.isDeclaratorVariable   || 
                    stack.isDeclaratorFunction   || 
                    stack.isDeclaratorTypeAlias 
                ){
                    stack.annotations = annotations.splice(0, annotations.length);
                    stack.metatypes = metatypes.splice(0, metatypes.length);
                    stack.imports = imports.splice(0,imports.length);
                    if( stack.imports.length >0 && !(stack.isClassDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration)){
                        stack.imports.forEach( item=>item.error(1094) );
                    }
                    this.body.push(stack);
                }else{
                    const imps = imports.splice(0,imports.length);
                    imps.forEach( item=>this.externals.push(item) );
                    this.externals.push(stack);
                }
            }
        });
        this.body.forEach(stack=>stack.createCompleted());
        this.externals.forEach( stack=>{
            if( stack.isImportDeclaration ){
                const module = compilation.getModuleById( stack.value() );
                if( !(module && module.isModule) ){
                    stack.error(1026,stack.value());
                }
            }
        });
    }
    freeze(){
        super.freeze(this);
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach(stack=>stack.freeze());
        this.externals.forEach(stack=>stack.freeze());
    }
    parser(){
        this.annotations.some( item=>{
            switch (item.name) {
                case 'Runtime':
                    const args = item.getArguments();
                    const value = (args[0].value || '').toLowerCase();
                    if( value ==='server'){
                        this.compilation.setPolicy(CompilationClass.POLICY_SERVER);
                    }else if( value ==='client' ){
                        this.compilation.setPolicy(CompilationClass.POLICY_CLIENT);
                    }else if( value ==='all' ){
                        this.compilation.setPolicy(CompilationClass.POLICY_ALL);
                    }else{
                        item.error(1092);
                    }
                    break;
                default:
                    item.error(1093);
                    break;
            }
        });
        this.body.forEach(item =>{
            item.parser();
        });
        this.externals.forEach( stack=>{
            if( !stack.isImportDeclaration ){
                stack.parser();
            }
        });
    }
    checker(){
        this.body.forEach(item =>{
            item.checker();
        });
        this.externals.forEach( stack=>{
            if( !stack.isImportDeclaration ){
                stack.checker();
            }
        });
    }
}

module.exports = Program;