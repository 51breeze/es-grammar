const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
class ForOfStatement extends Stack{

    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isForOfStatement= true;
        this.left  = Utils.createStack(compilation,node.left,scope,node,this);
        this.right = Utils.createStack(compilation,node.right,scope,node,this);
        this.body  = Utils.createStack(compilation,node.body,scope,node,this);
    }
    freeze(){
        super.freeze();
        this.left.freeze();
        this.right.freeze();
        this.body.freeze();
    }
    definition(){
        return null;
    }
    parser(){
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        this.body && this.body.parser();
    }
    checker(){
        this.left.checker();
        this.right.checker();
        this.body && this.body.checker();
        const desc = this.right.description();
        const iterator = this.getGlobalTypeById("Iterator");
        let type = desc.type();
        if( type.isLiteralArrayType ){
            type = type.extends[0];
        }
        if( !type.isAnyType ){
            if( type.is( iterator ) )return;
            this.right.error(1049,this.right.raw());
        }
        if( this.left.isVariableDeclaration ){
            if( this.left.declarations.length > 1 ){
                this.left.declarations[1].error(1047,'for-of');
            }
            if( this.left.declarations[0].init ){
                this.left.declarations[0].init.error(1048,'for-of');
            }
        }
        const checkItems = new Set();
        const getCheckItems = (desc)=>{
            if( !desc )return [];
            let items = [];
            if( (desc.isStack && desc.isDeclarator) || desc.isPropertyDefinition){
                if( desc.acceptType && !desc.acceptType.type().isAnyType ){
                    checkItems.add( desc.acceptType.type() )
                }else{
                    items = Array.from(desc.assignItems);
                }
            }else if( desc.isMethodDefinition || desc.isFunctionDeclaration ){
                if( desc.returnType && !desc.returnType.type().isAnyType ){
                     checkItems.add( desc.returnType.type() )
                }else{
                    items = desc.scope.returnItems.map( item=>item.argument );
                    if( desc.isMethodGetterDefinition ){
                        const name = desc.key.value()
                        const setter = this.module.getMember(name , "set");
                        if( setter ){
                            items = items.concat( Array.from(setter.assignItems) );
                        }
                    }
                }
            }else{
                items.push( desc );
            }
            items.forEach( item=>{
                if(item.isArrayExpression || item.isLiteral || item.isObjectExpression || item.isModule){
                    if( item.isModule ){
                        checkItems.add( item );
                    }else{
                        checkItems.add( item.type() );
                    }
                }else{
                    const desc = item.description();
                    if( item !== desc){
                        getCheckItems( desc );
                    }
                }
            });
        }
        getCheckItems( desc );
        const result =  Array.from(checkItems).every( type=>{
            return type.is( iterator );
        });
        if( !result ){
            this.right.warn(1049,this.right.raw());
        }
    }
}

module.exports = ForOfStatement;