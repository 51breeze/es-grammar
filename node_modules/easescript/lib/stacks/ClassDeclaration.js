const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const ClassScope = require("../scope/ClassScope");
class ClassDeclaration extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        scope = new ClassScope(scope);
        super(compilation,node,scope,parentNode,parentStack);
        this.isClassDeclaration= true;
        this._metatypes = [];
        this._annotations = [];
        this.imports     = [];
        this.id          = Utils.createStack(compilation,node.id,scope,node,this);
        const module = this.module = compilation.createModule(this.namespace, this.id.value());
        this.id.module = module;
        this.abstract = Utils.createStack(compilation,node.abstract,scope,node,this);
        this.inherit     = Utils.createStack(compilation,node.superClass,scope,node,this);
        if( node.superClass && node.superClass.genericity ){
            this.inherit.assignGenerics = node.superClass.genericity.map( item=>Utils.createStack(compilation,item,scope,node,this) );
        }
        this.static      = Utils.createStack(compilation,node.static,scope,node,this);
        this.implements  = (node.implements || []).map((item)=>{
            const stack = Utils.createStack(compilation,item,scope,node,this);
            if( item.genericity ){
                stack.assignGenerics = item.genericity.map( item=>Utils.createStack(compilation,item,scope,node,this) );
            }
            return stack;
        });
        this.modifier    = Utils.createStack(compilation,node.modifier,scope,node,this);
        this.genericity  = Utils.createStack(compilation,node.genericity,scope,node,this);
        this.dynamic = false;
        module.abstract  = !!this.abstract;
        module.isClass   = true;
        module.dynamic   = false;
        module.genericity = this.genericity;
        module.comments   = this.comments;
        compilation.addModuleStack(module,this);
    }

    set metatypes(value){
        this._metatypes = value;
    }

    get metatypes(){
       return this._metatypes;
    }

    set annotations(value){
        this._annotations = value;
        this.dynamic = value.some( (annotation)=>{
            return annotation.name.toLowerCase() ==="dynamic";
        });
        this.module.dynamic = this.dynamic;
    }

    get annotations(){
        return this._annotations;
    }

    freeze(){
        super.freeze(this);
        super.freeze(this.id); 
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.abstract);
        super.freeze(this.metatypes);
        super.freeze(this.annotations);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        this.body.forEach(stack=>stack.freeze());
    }

    createCompleted(){
        const metatypes = [];
        const annotations = [];
        const compilation = this.compilation;
        const scope = this.scope;
        const node  = this.node;
        this.imports.forEach( stack=>{
            const module = compilation.getModuleById( stack.value() );
            if( module && module.isModule ){
                if( Utils.checkDepend(this.module,module) ){
                    stack.error(1024,stack.value())
                }
                const nameId = stack.alias ? stack.alias.value() :  module.id;
                if( !this.module.addImport(nameId, module, module.id != nameId ) ){
                    stack.error(1025,nameId)
                } 
            }else{
                stack.error(1026,stack.value())
            }
        });

        if( this.inherit ){
            const inheritModule = this.getModuleById( this.inherit.value() );
            this.module.extends = inheritModule;
            if( inheritModule ){
                inheritModule.used = true;
                inheritModule.children.push( compilation.module );
                this.compilation.addDependency(inheritModule,this.module );
            }else{
                this.inherit.error(1027,this.inherit.value())
            }
        }
        this.module.implements = this.implements.map( (stack)=>{
            const module = this.getModuleById( stack.value() );
            if( module ){
                if( !module.isInterface ){
                    stack.error(1028,stack.value());
                }
                module.used = true;
                this.compilation.addDependency(module,this.module );
            }else {
                stack.error(1029,stack.value());
            }
            return module;
        });
        this.body = (node.body.body || []).map( item=>{
            const stack = Utils.createStack( compilation, item, scope, node ,this);
            if( stack.isMetatypeDeclaration ){
                metatypes.push( stack );
            }else if( stack.isAnnotationDeclaration ){
                annotations.push( stack );
            }else{
                stack.metatypes   = metatypes.splice(0,metatypes.length);
                stack.annotations = annotations.splice(0,annotations.length);
                return stack;
            }
        }).filter( item=>!!item );
    }

    genericsCheck(typeModule, assignGenerics){
        const stackModule = this.compilation.getStackByModule( typeModule );
        if( stackModule ){
            assignGenerics = assignGenerics || [];
            const declareGenerics = stackModule.genericity ? stackModule.genericity.elements : [];
            const requires = declareGenerics.filter( item=>!item.isGenericTypeAssignmentDeclaration );
            const lastStack = assignGenerics[ assignGenerics.length-1 ] || this.inherit;
            if( requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length ){
                if( requires.length === declareGenerics.length ){
                    lastStack.error(1030, typeModule.toString(), requires.length);
                }else{
                    lastStack.error(1031,typeModule.toString(), requires.length, declareGenerics.length);
                }
            }
            if( declareGenerics.length > 0 ){
                assignGenerics.forEach( (item,index)=>{
                    const declareType = declareGenerics[index] && declareGenerics[index].type();
                    if( declareType && declareType.hasConstraint && !declareType.check(item) ){  
                        item.error(1003,item.type().toString(),declareType.toString());
                    }
                });
            }
        }
    }

    implementCheck(interfaceModule){
        const check = (left,right)=>{
            if( !left )return;
            if(left.modifier && left.modifier.value() ==="private")return;
            const type = left.isAccessor ? (left.kind=='set'?'setter':'getter') : left.isPropertyDefinition ? "property" : "method";
            if( !right ){
                const impStack = this.implements.find( (stack)=>{
                    return interfaceModule === this.getModuleById( stack.value() );
                });
                return impStack.error(1032,left.value(),type,interfaceModule.getName(),this.module.getName());
            }
            if( !Utils.checkTypeForBoth(left.type(),right.type()) ){
                right.error(1033,right.value(),type,interfaceModule.getName());
            }
            if( left.isMethodDefinition ){
                if( !right.isMethodDefinition ){
                    right.error(1034,left.value(),type,interfaceModule.getName());
                }
                const paramLen = left.params.length;
                if( paramLen != right.params.length ){
                    right.error(1090,left.value(),interfaceModule.getName());
                }else if( paramLen > 0 ){
                    const lT = !!left.params[ paramLen-1 ].isRestElement;
                    const rT = !!right.params[ paramLen-1 ].isRestElement;
                    if( lT !== rT){
                        right.error(1090,left.value(),interfaceModule.getName());
                    }
                }
                const result = left.params.every( (item,index)=>{
                    return right.params[index] ? Utils.checkTypeForBoth(item.type(),right.params[index].type() ) : false;
                });
                if( !result ){
                    right.error(1036, left.value(),type,interfaceModule.getName());
                }
                const lGens = left.genericity ? left.genericity.elements.length : 0;
                const rGens = right.genericity ? right.genericity.elements.length : 0;
                if( lGens > 0 && lGens !== rGens ){
                    right.error(1037,left.value(),type,interfaceModule.getName());
                }
                if( lGens > 0 ){
                    const result= left.genericity.elements.every( (leftGeneric,index)=>{
                        const rightGeneric = right.genericity.elements[index];
                        return leftGeneric.type().check( rightGeneric, true )
                    });
                    if( !result ){
                        right.error(1038,left.value(),type,interfaceModule.getName());
                    }
                }
            }else {
                if( !right.isPropertyDefinition ){
                    right.error(1034, left.value(), type, interfaceModule.getName());
                }
            }
            if( right.modifier && right.modifier.value() !=="public" ){
                right.error(1039,right.value(),type,interfaceModule.getName());
            }
        }
        if( Utils.isInterface(interfaceModule) && interfaceModule !== this.module ){
            const members = interfaceModule.members || {};
            for(var name in members){
                const left = members[name];
                if( left.isAccessor ){
                    check(left.get,this.module.getMember(name,"get"));
                    check(left.set,this.module.getMember(name,"set"));
                }else{
                    check(left,this.module.getMember(name));
                }
            }
        }
        
        if( Utils.isInterface(interfaceModule) ){
            interfaceModule.extends.forEach( item=>{
                this.implementCheck(item);
            });
        }
        (interfaceModule.implements||[]).forEach( item=>{
            this.implementCheck(item);
        });
    }
    definition(){
        const kind = "Class";
        return {
            kind:"Module",
            comments:this.comments,
            identifier:this.id.value(),
            expre:`(${kind}) ${this.module.getName()}`,
            location:this.id.getLocation(),
            file:this.file,
            context:this
        };
    }
    value(){
        return this.id.value();
    }
    parser(){
        if( !super.parser() ){
            return false;
        }

        if( this.inherit ){
            this.module.policy = this.module.extends[0].policy;
            this.genericsCheck( this.module.extends[0], this.inherit.assignGenerics);
        }

        if( this.genericity ){
            this.genericity.parser();
        }
        this.metatypes.forEach( item=>item.parser() )
        this.annotations.forEach( item=>{
            item.parser();
            switch (item.name) {
                case 'Runtime':
                    const args = item.getArguments();
                    const value = (args[0].value || '').toLowerCase();
                    if( value ==='server'){
                        this.compilation.setPolicy(CompilationClass.POLICY_SERVER, this.module);
                    }else if( value ==='client' ){
                        this.compilation.setPolicy(CompilationClass.POLICY_CLIENT, this.module);
                    }else if( value ==='all' ){
                        this.compilation.setPolicy(CompilationClass.POLICY_ALL, this.module);
                    }else{
                        item.error(1092);
                    }
            }
        });
        this.module.implements.forEach( (impModule,index)=>{
            this.genericsCheck( impModule, this.implements[index].assignGenerics);
        });
        this.implementCheck( this.module );
        this.body.forEach(item =>{
            item.parser();
        });
        return true;
    }
    checker(){
        if( !super.checker() ){
            return false;
        }
        this.metatypes.forEach( item=>item.checker() )
        this.annotations.forEach( item=>item.checker() )
        if( this.genericity ){
            this.genericity.checker();
        }
        this.body.forEach(item =>{
            item.checker();
        });
        return true;
    }
}

module.exports = ClassDeclaration;