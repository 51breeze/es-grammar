const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const Module = require("../core/Module");
const Expression = require("./Expression");
const UnionType = require("../types/UnionType");
const TupleType = require("../types/TupleType");
const AnyType = require("../types/AnyType");
const Property = require("./Property");
const keySymbol = Symbol("key");
class MemberExpression extends Expression{
   constructor(compilation,node,scope,parentNode,parentStack){
      super(compilation,node,scope,parentNode,parentStack);
      this.isMemberExpression = true;
      this.object = Utils.createStack( compilation, node.object, scope, node, this );
      this.property = Utils.createStack( compilation, node.property, scope, node,this );
      this._accessor = null;
      this.computed = !!node.computed;
      this[keySymbol]={};
   }
   freeze(){
      super.freeze();
      this.object.freeze();
      this.property.freeze();
   }
   reference(called){
      const description = this.getDescription();
      if( description !== this && description instanceof Stack ){
          return description.reference(called);
      }
      return this;
   }
   referenceItems(called){
      const description = this.getDescription();
      if( description !== this && description instanceof Stack ){
         return description.referenceItems(called);
      }
      return [this];
   }
   definition(){
      if( this.parentStack.isCallExpression && this.parentStack.callee === this){
         return this.parentStack.definition();
      }
      const context = this.computed ? this.property.description() : this.description();
      const def = context ? context.definition() : null;
      if( def && this.node.loc ){
         def.range = this.node.loc;
      }
      return def;
   }
   set accessor( val ){
       this._accessor = val;
       this.object.accessor = val;
   }
   getDescription(){
      let property = this.property.value();
      let description = this.object.description();
      if( !description )return null;
      if( description.isNamespace ){
         return description.get(property);
      }
      if( this.computed ){
         if( this.property.isIdentifier ){
            const refs = this.property.reference();
            const desc = this.property.description();
            if( refs === this.property && !(desc.isDeclarator && desc instanceof Stack) ){
               this.computed = false;
            }
         }
         if( this.computed ){
            description = new AnyType();
            description.computed = true;
            return description;
         }
      }

      const inference=(target, property)=>{
         if(!target || !(target instanceof Stack))return null;
         const refs = target.referenceItems();
         let last = null;
         const result = refs.every( item=>{
             const type = item.type();
             const value = target !== item ? getRefs(type, property, item ) : null;
             if( last && value && last.type() !== value.type() ){
                return false;
             }
             last = value;
             return !!(value && !value.isAnyType);
         });
         if( result ){
            return last;
         }
         return null;
      }

      const getRefs=(classModule, property, target)=>{
         if( !classModule )return null;
         if(classModule.isGenericValueType){
            classModule = classModule.value;
         }
         if( classModule.isAnyType ){
            return classModule;
         }
         if( target && classModule===this.getGlobalTypeById("object") ){
            const result = inference(target,property);
            if( result ){
               return result; 
            }
         }
         
         let isModule = classModule instanceof Module;
         let isStatic = target && classModule === target.description();
         //let isStatic = isModule && (classModule.isClass || classModule.isEnum);

         if( !isModule ){
            if( classModule instanceof UnionType ){
               let len = classModule.elements.length;
               for(;len>0;--len){
                  const itemType = classModule.elements[len];
                  const resultStack = getRefs(itemType, property);
                  if( resultStack )return resultStack;
               }
               return null;
            }else if( classModule instanceof TupleType){
               return this.compilation.getReference(property,Utils.getOriginType(classModule),false,this._accessor);
            }else if( classModule.isClassGenericType && classModule.isClassType ){
               classModule = classModule.types[0];
               while(classModule.isClassGenericType){
                  if( classModule.isClassType ){
                     classModule = classModule.types[0];
                  }else{
                     classModule = classModule.extends[0];
                  }
               }
               if( classModule === this.getGlobalTypeById("any") ){
                  return classModule;
               }
               isStatic = classModule instanceof Module && classModule.isClass;
            }else if( (classModule.isLiteralArrayType || classModule.isLiteralObjectType || classModule.isGenericType || classModule.isEnumType )===true ){
               let desc = classModule.attribute(property);
               if(desc){
                  if( desc.computed && desc.isProperty){
                     desc = new AnyType();
                     desc.computed = true;
                  }
                  return desc;
               }
            }
            if( !classModule.isModule ){
               classModule = Utils.getOriginType(classModule);
            }
         }
         return this.compilation.getReference(property,classModule,isStatic,this._accessor);
      }
      return getRefs(this.object.type(), property, this.object);
   }

   description(){
      let desc = this.__description;
      if( desc !== void 0 ){
         return desc;
      }
      this.__description = desc = this.getDescription();
      if( !desc ){
         const module =  this.module;
         desc = this.getModuleById( this.value() ) || null;
         if( desc && Utils.isClassType(desc) && desc !== module ){
            this.compilation.addDependency(desc, this.module);
         }
         this.__description = desc;
      }
      return desc;
   }

   getGenericTypes(){
      if( this[keySymbol]._relatedGenericTypes ){
          return this[keySymbol]._relatedGenericTypes;
      }
      const targetType = this.object.type();
      const relatedTypes = new Map();
      const merge=(types)=>{
          types && types.forEach( (value,key)=>{
              relatedTypes.set(key, value);
          });
      }
      if( targetType ){
          if( targetType.isTupleType || targetType.isLiteralArrayType){
              const originType = Utils.getOriginType( targetType );
              if( originType && originType.isModule ){
                  const createType =()=>{
                      if( targetType.isLiteralArrayType ){
                          const hash = new Set();
                          targetType.elements.map(item=>{
                              const type = item.type();
                              hash.add( type.isLiteralType ? type.inherit : type );
                          });
                          const items = Array.from( hash.values() );
                          if( items.length > 1 ){
                              return new UnionType(items, targetType);
                          }
                          return items[0];
                      }else {
                          return new TupleType( targetType.inherit, targetType.elements.map(item=>{
                              const type = item.type();
                              if( type.rest ){
                                  return type.elements[0].type();
                              }
                              return type;
                          }),targetType.target, targetType.rest, true );
                      }
                  }
                  const declareGenerics = originType.getModuleGenerics();
                  const assignType = targetType.elements.length===0 ? this.getGlobalTypeById('any') : 
                                      targetType.elements.length===1 ? targetType.elements[0].type() : createType();
                  declareGenerics.forEach( (item)=>{
                      relatedTypes.set( item.type(), assignType);
                  });
              }

          }else if( targetType.target && (targetType.isClassGenericType || targetType.isInstanceofType) ){
              merge( targetType.target.getGenericTypes() );
          }
      }
      this[keySymbol]._relatedGenericTypes = relatedTypes;
      return relatedTypes;
   }

   type(){
      const description = this.description();
      if( description ){
         return description.type().clone( this.inference() );
      }
      return this.getGlobalTypeById("any");
   }

   isProtectedAccessible(target){
      if( target === this.module ){
         return true;
      }
      let parent = this.module;
      while( parent = parent.extends[0] ){
         if(parent===target)return true;
      }
      return false;
   }

   checker(){
      this.object.checker();
      this.computed && this.property.checker();
      const desc = this.description();
      if( !desc ){
         const baseObject = this.object.description();
         const baseObjectType = baseObject ? Utils.getOriginType(baseObject.type()) : null;
         const isDynamic = baseObjectType && baseObjectType.dynamic;
         if( !isDynamic && !this.parentStack.isMemberExpression ){
            this.property.error(1060,this.raw());
         }
      }else if( desc.isMethodDefinition || desc.isPropertyDefinition ){
         const modifier = desc.modifier ? desc.modifier.value() : 'public';
         if( modifier !=="public" && this.scope.type("top") ){
            this.property.error(1061,this.raw());
         }else if( modifier === "private" && desc.module !== this.module ){
            this.property.error(1061,this.raw());
         }else if(modifier === "protected" && !this.isProtectedAccessible(desc.module) ){
            this.property.error(1061,this.raw());
         }
      }
   }
   
   parser(){
      if( super.parser() === false )return false;
      this.object.parser();
      if( this.computed ){
         this.property.parser();
         this.property.setRefBeUsed();
      }
      let desc = this.object.description();
      this.object.setRefBeUsed(desc);
      if(desc && desc.isStack && this.parentStack && this.parentStack.isAssignmentExpression){
         desc = desc.reference();
         if( desc && desc.isObjectExpression ){
            const propertyName = this.property.value();
            if( !desc.hasAttribute(propertyName) ){
               const target = new Property(this.compilation,this.property.node,this.scope,this.parentNode);
               target.parentStack = this;
               target.namespace   = this.namespace;
               target.module      = this.module;
               target.key         = this.property;
               //target.acceptType  = this.getGlobalTypeById("any");
               target.kind        = 'dynamic';
               desc.attribute(propertyName, target);
            }
         }
      }
      const description = this.description();
      if( description && description.isStack ){
          description.parser();
      }
   }

   raw(){
      if( this.computed ){
         return `${this.object.raw()}[${this.property.raw()}]`;
      }
      return `${this.object.raw()}.${this.property.raw()}`;
   }

   value(){
      if( this.computed ){
         return `${this.object.value()}[${this.property.raw()}]`;
      }
      return `${this.object.value()}.${this.property.value()}`;
   }
}

module.exports = MemberExpression;
