const Utils = require("../core/Utils");
const Expression = require("./Expression");
const Stack = require("../core/Stack");
const TupleType = require("../types/TupleType");
const UnionType = require("../types/UnionType");
const keySymbol = Symbol("key");
class CallExpression extends Expression{

    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isCallExpression= true;
        this.callee = Utils.createStack( compilation, node.callee, scope, node, this );
        this.arguments = node.arguments.map( item=>Utils.createStack( compilation,item,scope,node,this) );
        this.genericity=null;
        if( node.genericity ){
            this.genericity = node.genericity.map(item=>Utils.createStack(compilation,item,scope,node,this));
        }
        this[keySymbol]={};
    }

    freeze(){
        super.freeze(this);
        this.callee.freeze();
        super.freeze(this.genericity);
        (this.genericity || []).forEach( stack=>stack.freeze() );
    }

    definition(){
        const identifier = this.callee.value();
        const context    = this.description(true);
        if( !context && this.parentStack.isWhenStatement){
            const type = 'boolean';
            const context = this;
            const params  =  this.arguments.map( (item)=>item.value() );
            return {
                kind:"method",
                comments:context.comments,
                identifier:identifier,
                expre:`(Metatype method) ${identifier}(${params.join(",")}):${type}`,
                location:this.callee.getLocation(),
                file:this.compilation.file,
                context
            };
        }
        if( !context )return null;
        if( context && (context.isType && context.isAnyType) ){
            return {
                kind:"call",
                identifier:identifier,
                expre:`any`,
            };
        }
        const def = context.definition(true, this.inference(null,true) );
        if( def && this.callee.node.loc ){
            def.range = this.callee.node.loc;
        }
        return def;
    }

    reference(){
        let description = this.description();
        if( description ){
            if( description instanceof Stack ){
                return description.reference(true);
            }else if( description.isFunctionType ){
                return description.type(true);
            }
        }
        return null;
    }

    referenceItems(){
        let description = this.description();
        if( description ){
            if( description instanceof Stack ){
                return description.referenceItems(true);
            }else if( description.isFunctionType ){
                return [].concat( description.type(true) );
            }
        }
        return [];
    }

    description( flag ){
        let desc = this.callee.description();
        if( !desc )return this.getGlobalTypeById("any");
        if( Utils.isTypeModule(desc) ){
            this.compilation.addDependency(desc,this.module );
        }
        if( desc && Utils.isClassType(desc) && desc.callable){
            desc = desc.callable;
        }
        if( !flag ){
            if( desc && desc.isProperty && !desc.hasAssignmentPattern){
                desc = desc.description();
            }
            if( desc && desc.isDeclarator ){
                desc = desc.type();
            } 
        }
        return desc;
    }

    value(){
        return this.callee.value();
    }

    getGenericTypes(){
        if( this[keySymbol]._relatedGenericTypes ){
            return this[keySymbol]._relatedGenericTypes;
        }
        const targetType = this.callee.isMemberExpression ? this.callee.object.type() : (this.callee.isSuperExpression ? this.callee.type() : null);
        const relatedTypes = new Map();
        const desc = this.description();
        const declareMethodGenerics = desc && desc.genericity ? desc.genericity.elements : [];
        const merge=(types)=>{
            types && types.forEach( (value,key)=>{
                relatedTypes.set(key, value);
            });
        }
        if( targetType ){
            if( targetType.isTupleType || targetType.isLiteralArrayType){
                const originType = Utils.getOriginType( targetType );
                if( originType && originType.isModule ){
                    const createType =()=>{
                        if( targetType.isLiteralArrayType ){
                            const hash = new Set();
                            targetType.elements.map(item=>{
                                const type = item.type();
                                hash.add( type.isLiteralType ? type.inherit : type );
                            });
                            const items = Array.from( hash.values() );
                            if( items.length > 1 ){
                                return new UnionType(items, targetType);
                            }
                            return items[0];
                        }else {
                            return new TupleType( targetType.inherit, targetType.elements.map(item=>{
                                const type = item.type();
                                if( type.rest ){
                                    return type.elements[0].type();
                                }
                                return type;
                            }),targetType.target, targetType.rest, true );
                        }
                    }
                    const declareGenerics = originType.getModuleGenerics();
                    const assignType = targetType.elements.length===0 ? this.getGlobalTypeById('any') : 
                                        targetType.elements.length===1 ? targetType.elements[0].type() : createType();
                    declareGenerics.forEach( (item)=>{
                        relatedTypes.set( item.type(), assignType);
                    });
                }

            }else if( targetType.target && (targetType.isClassGenericType || targetType.isInstanceofType) ){
                merge( targetType.target.getGenericTypes() );
            }
        }
        if( this.genericity ){
            declareMethodGenerics.forEach( (item,index)=>{
                const type = item.type();
                const assign = this.genericity[index];
                if( assign ){
                    relatedTypes.set( type, assign.type() );
                }else if( type.assignType ){
                    relatedTypes.set( type, type.assignType  );
                }
            });
        }else{
            const declareParams = desc.params;
            declareParams.forEach( (item,index)=>{
                const type = item.type();
                if( type && type.isGenericType && type.isFunGeneric && !type.assignType && !type.hasConstraint && this.arguments[index] ){
                    relatedTypes.set( type, this.arguments[index].type() );
                }
            });
        }
        this[keySymbol]._relatedGenericTypes = relatedTypes;
        return relatedTypes;
    }

    type(){
        if( this[keySymbol]._type ){
            return this[keySymbol]._type;
        }
        let description = this.description();
        if( description ){
            if( this.callee.isMemberExpression ){
                const tType = this.callee.object.type();
                if( tType && tType.isFunctionType ){
                    const fModule = tType.inherit; 
                    if( fModule && fModule.getMember('bind') === description){
                        return this[keySymbol]._type = tType;
                    }
                }
            }
            return this[keySymbol]._type = description.type(true).clone( this.inference() );
        }else{
            return this[keySymbol]._type = this.getGlobalTypeById('any');
        }
    }

    checker(){
        this.callee.checker();
        this.arguments.forEach(item=>item.checker());
        let description = this.description();
        if( !description || description.isAnyType ){
            return;
        }
        if( !(description.callable || this.callee.isSuperExpression || description.isFunctionType) ){
            return this.error(1006,this.value());
        }
        const declareGenerics = description.genericity ? description.genericity.elements : [];
        if( this.genericity ){
            const last = this.genericity[ this.genericity.length-1 ];
            if( declareGenerics.length < 1 ){
                last.error(1004,0,this.genericity.length);
            }
            const requires = declareGenerics.filter( item=>!item.isGenericTypeAssignmentDeclaration );
            if( requires.length > this.genericity.length ){
                if( requires.length === declareGenerics.length ){
                    last.error(1004,requires.length,this.genericity.length);
                }else{
                    last.error(1005,requires.length,declareGenerics.length,this.genericity.length);  
                }
            }
            this.genericity.forEach( (item,index)=>{
                 const declareType = declareGenerics[index] && declareGenerics[index].type();
                 if( declareType && declareType.hasConstraint && !declareType.check(item) ){  
                    item.error(1003,item.type().toString(),declareType.toString());
                 }
            });
        }

        const declareParams = description.isFunctionType && description.target ? description.target.params : description.params;
        const declareTypeParams = description.params;
        const length = declareParams.length;
        let requireCount = length;
        let hasRest = false;
        if( length > 0 ){
            const rest = declareParams[ length-1 ].isRestElement ? declareParams[ length-1 ] : null;
            const restType = rest ? declareTypeParams[ length-1 ] : null;
            const args = this.arguments.map( (item,index)=>{
                if( declareParams[index] && declareParams[index] !== rest ){
                    const declareParam = declareTypeParams[index];
                    let acceptType = declareParam && declareParam.type();
                    let orgType = acceptType;
                    if(acceptType && acceptType.isGenericType ){
                        if( declareParam.parentStack && declareParam.parentStack.isTypeFunctionDefinition ){
                            const origin = this.callee.description();
                            if( origin.isParamDeclarator ){
                                acceptType = origin.getTypeByGeneric( acceptType, true, true );
                            }
                        }else{
                            acceptType = this.getTypeByGeneric( acceptType, true, true);
                        }
                    }
                    if( acceptType && !acceptType.check(item,true) ){
                        if( orgType.hasConstraint ){
                            item.error(1003, item.type().toString(), orgType.toString());
                        }else{
                            item.error(1002,item.type().toString(),acceptType.clone(this.inference(this,true)).toString());
                        }
                    }
                }
                if( item.isSpreadElement && this.arguments[ this.arguments.length-1 ] !== item ){
                    item.error(1084);
                }
                return item;
            });
            if( restType ){
                hasRest = true;
                requireCount = length-1;
                const tupleType = restType.type().clone( this.inference(null,true) );
                const errorItems = [];
                if( !tupleType.checkItems( args.slice( length-1 ), errorItems ) ){
                    errorItems.forEach( item=>{
                        item.error(1002,item.type().toString(),tupleType.toString());
                    });
                }
            }
            const check = declareParams.every( (item,index)=>{
                if( item.isAssignmentPattern || item.isRestElement || item.question ){
                    return true;
                }
                return !!args[index];
            });
            if( !check ){
                this.error(1000,requireCount,args.length);
            }
        }
        if( !hasRest && this.arguments.length > length ){
            this.error(1000,declareParams.length,this.arguments.length);
        }
    }
    parser(){
        if( super.parser() === false )return false;
        this.callee.parser();
        this.callee.setRefBeUsed();
        this.arguments.forEach(item=>{
            item.parser();
            item.setRefBeUsed();
        });
    }

    value(){
        return this.callee.value();
    }

    raw(){
        const callee= this.callee.raw();
        const args = this.arguments.map( item=>item.raw() );
        if( this.genericity ){
            const genericity = this.genericity.map( item=>item.raw() );
            return `${callee}<${genericity.join(",")}>(${args.join(",")})`;
        }
        return `${callee}(${args.join(",")})`;
    }
}

module.exports = CallExpression;