const Expression = require("./Expression");
const InstanceofType = require("../types/InstanceofType");
class SuperExpression  extends Expression {
    constructor(compilation,node,scope,parentNode,parentStack){ 
        super(compilation,node,scope,parentNode,parentStack);
        this.isSuperExpression= true;
        const fnScope = scope.getScopeByType("function");
        if( fnScope.isMethod && fnScope.isConstructor && !fnScope.hasSuper ){
            fnScope.firstSuperIndex = parentStack.childrenStack.length;
            fnScope.hasSuper = true;
        }
    }
    definition(){
        if( this.parentStack.isCallExpression ){
            return this.parentStack.definition();
        }
        const context = this.module.extends[0];
        return context && context.definition();
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    description(){
        if( !this.parentStack.isMemberExpression ){
           const parent = this.module.extends[0];
           const methodConstructor = parent && parent.getConstructMethod();
           if( methodConstructor ){
               return methodConstructor;
           }else{
               return {
                    params:[],
                    callable:true,
                    isConstructor:true,
                    stack:this,
                    description(){
                        return this;
                    },
                    type(){
                        return parent;
                    }
                }
           }
        }
        return this;
    }
    getGenericTypes(){
        if( this.__relatedGenericTypes !== void 0 ){
            return this.__relatedGenericTypes;
        }
        const parentType = this.module.extends[0];
        this.__relatedGenericTypes = null;
        if( parentType ){
            const declareGenerics = parentType.getModuleGenerics();
            const relatedTypes = new Map();
            if( declareGenerics ){
                const moduleStack = this.compilation.getStackByModule( this.module );
                const assignGenerics = moduleStack.inherit.assignGenerics;
                if( assignGenerics ){
                    declareGenerics.forEach( (item,index)=>{
                        const assign = assignGenerics[index];
                        if( assign ){
                            relatedTypes.set( item.type(), assign.type() );
                        }
                    });
                }
            }
            this.__relatedGenericTypes = relatedTypes;
        }
        return this.__relatedGenericTypes;
    }
    type(){
        return this._type || (this._type = new InstanceofType(this.module.extends[0], this));
    }
    parser(){
        const stack = this.getParentStack( (stack)=>{
           return !!stack.isFunctionExpression;
        });
        if( !stack || !(stack.parentStack.isMethodDefinition) || stack.parentStack.static){
            this.error(1076)
        }
        const parent = this.module && this.module.extends[0];
        if( !parent ){
            this.error(1075);
        }
    }
    value(){
        return `super`;
    }
    raw(){
        return `super`; 
    }
}

module.exports = SuperExpression;