const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
class ReturnStatement extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isReturnStatement= true;
        this.argument = Utils.createStack( compilation, node.argument, scope, node,this );
        const fnScope = scope.getScopeByType("function");
        this.returnIndex = fnScope.returnItems.length;
        if( this.argument ){
            fnScope.returnItems.push( this );
        }
        this.fnScope = fnScope;
    }
    freeze(){
        super.freeze();
        this.argument && this.argument.freeze();
    }
    definition(){
        return null;
    }
    reference(){
        if( this.argument ){
            return this.argument.reference();
        }
        return null;
    }
    referenceItems(){
        return this.argument ? this.argument.referenceItems() : [];
    }
    description(){
        if( this.argument ){
            return this.argument.description();
        }
        return null;
    }
    type(){
        if( !this.argument ){
            return this.getGlobalTypeById("void");
        }
        return this.argument.type();
    }
    checker(){
        if( this.argument ){
            this.argument.checker();
        }
        let parent =  this.getParentStack( parent=>{
            return !!parent.isFunctionExpression;
        });
        if( !parent || !parent.isFunctionExpression){
            return this.error(1072);
        }
        if( parent.async ){
            return;
        }
        if( this.argument ){
            if( this.argument.type().isNullableType ){
                return;
            }
            let returnType = parent && parent.returnType;
            if( returnType ){
                const type = returnType.type();
                if( !type.check( this.argument ) ){
                    this.error(1009,this.argument.type().toString(),type.toString());
                }
            }else{
                const index = this.returnIndex;
                if( index > 0){
                    const prevReturn = this.fnScope.returnItems[ index-1 ];
                    const type = prevReturn && prevReturn.type();
                    if( !type.check( this.argument ) ){
                        this.error(1009,this.argument.type().toString(),type.toString());
                    }
                }
            }
        }
    }
    parser(){
        if( this.argument ){
            this.argument.parser();
            this.argument.setRefBeUsed();
        }
    }

    value(){
        return this.argument ? this.argument.value() : '';
    }

    raw(){
        return this.argument ? this.argument.raw() : '';
    }
}

module.exports = ReturnStatement;