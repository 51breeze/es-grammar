const Utils = require("../core/Utils");
const Expression = require("./Expression");
const Stack = require("../core/Stack");
const InstanceofType = require("../types/InstanceofType");
const keySymbol = Symbol("key");
class NewExpression extends Expression{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isNewExpression= true;
        this.callee = Utils.createStack( compilation, node.callee, scope, node,this );
        this.arguments = node.arguments.map( item=>{
            return Utils.createStack( compilation, item, scope, node,this );
        });
        this.genericity=null;
        if( node.genericity ){
            this.genericity = node.genericity.map(item=>Utils.createStack(compilation,item,scope,node,this));
        }
        this[keySymbol]={};
    }
    freeze(){
        super.freeze();
        super.freeze( this.arguments );
        super.freeze( this.genericity );
        this.callee.freeze();
        this.arguments.forEach( stack=>stack.freeze() );
        (this.genericity || []).forEach( stack=>stack.freeze() );
    }
    definition(){
        const desc = this.description();
        if( desc ){
            const classType = desc.type();
            if( classType.methodConstructor ){
                return classType.methodConstructor.definition(true, this.inference(this,true) );
            }
            const stack = this.compilation.getStackByModule( classType );
            if( stack ){
                const owner = classType.getName();
                const declareGenerics = classType.getModuleGenerics();
                let type = owner;
                if( declareGenerics ){
                    type = [type,'<',declareGenerics.map( type=>type.clone(inference) ).join(", "),'>'].join("")
                }
                
                return {
                    kind:"constructor",
                    comments:desc.comments,
                    identifier:stack.id.value(),
                    expre:`constructor ${classType.toString(true)}(): ${type}`,
                    location:stack.id.getLocation(),
                    file:this.file,
                    context:stack
                };
            }
        }
        return null;
    }
    reference(){
        return this;
    }
    referenceItems(){
        return [this];
    }
    description(){
        let desc = this.callee.description();
        if( !desc ){
            return null;
        }
        if( this.module && Utils.isTypeModule(desc) ){
            this.compilation.addDependency(desc,this.module );
        }
        if( desc.isDeclarator && desc instanceof Stack ){
            desc = desc.description();
        }
        return desc;
    }
    type(){
        if( this[keySymbol]._type ){
            return this[keySymbol]._type;
        }
        const description = this.description();
        return this[keySymbol]._type = new InstanceofType(description && description.type(),this);
    }

    getGenericTypes(){
        if( this[keySymbol]._relatedGenericTypes ){
            return this[keySymbol]._relatedGenericTypes;
        }
        const description = this.description();
        const originType = description.type();
        if( !(originType && originType.isModule) )return null;
        const declareGenerics = originType.getModuleGenerics();
        const relatedTypes = new Map();
        if( this.genericity ){
            const assigns = this.genericity;
            declareGenerics.forEach( (item,index)=>{
                const type = item.type();
                if( assigns[index] ){
                    relatedTypes.set( type, assigns[index].type() );
                }else if( type.assignType ){
                    relatedTypes.set( type, type.assignType );
                }
            });
        }else{
            const methodConstructor = originType.getConstructMethod();
            const declareParams = methodConstructor && methodConstructor.params || [];
            declareParams.forEach( (item,index)=>{
                const type = item.type();
                if( type.isGenericType ){
                    if( this.arguments[ index ] ){
                        relatedTypes.set(type, this.arguments[ index ].type() );
                    }else if( type.assignType ){
                        relatedTypes.set(type, type.assignType );
                    }
                }
            });
        }
        this[keySymbol]._relatedGenericTypes = relatedTypes;
        return relatedTypes;
    }

    checker(){
        this.callee.checker();
        this.arguments.forEach(item=>item.checker());
        const description = this.description();
        if( !description ){
            return;
        }
        let type = description.type();
        if( type.isAnyType ){
            return;
        }
        if( !(type.isModule && type.isClass) ){
            this.callee.error(1069,this.callee.value());
        }
        if(type.abstract){
            this.callee.error(1070,this.callee.value());
        }

        const methodConstructor = type.getConstructMethod();
        const params  = methodConstructor ? methodConstructor.params : [];
        const moduleStack = this.compilation.getStackByModule( type );
        const declareGenerics = moduleStack && moduleStack.genericity ? moduleStack.genericity.elements : [];
       
        if( this.genericity && this.genericity.length > 0 ){
            const lastStack = this.genericity[ this.genericity.length-1 ];
            if( declareGenerics.length < 1 ){
                lastStack.error(1004,0,this.genericity.length);
            }
            const requires = declareGenerics.filter( item=>!item.isGenericTypeAssignmentDeclaration );
            if( requires.length > this.genericity.length ){
                if( requires.length === declareGenerics.length ){
                    lastStack.error(1004,requires.length,this.genericity.length);
                }else{
                    lastStack.error(1005,requires.length,declareGenerics.length,this.genericity.length);
                }
            }
            this.genericity.forEach( (item,index)=>{
                const declareType = declareGenerics[index] && declareGenerics[index].type();
                if( declareType && declareType.hasConstraint && !declareType.check(item) ){  
                   item.error(1003,item.type().toString(),declareType.toString());
                }
            });
        }
        const length = params.length;
        let hasRest = false;
        if( length > 0 ){
            const rest = params[ length-1 ].isRestElement ? params[ length-1 ] : null;
            const args = this.arguments.map( (item,index)=>{
                if( params[index] && params[index] !== rest ){
                    let acceptType = params[index].type();
                    let orgType = acceptType;
                    if( acceptType.isGenericType ){
                        acceptType = this.getTypeByGeneric( acceptType, true, true )
                    }
                    if( acceptType && !acceptType.check(item,true) ){
                        if( orgType.hasConstraint ){
                            item.error(1003,item.type().toString(),acceptType.toString());
                        }else{
                            item.error(1002,item.type().toString(),acceptType.toString());
                        }
                    }
                }
                return item;
            });

            if( rest ){
                hasRest = true;
                const tupleType = rest.type().clone( this.inference(null,true) );
                const cloneArgs = args.slice( length-1 );
                const errorItems = [];
                if( !tupleType.checkItems( cloneArgs, errorItems ) ){
                    errorItems.forEach( item=>{
                        item.error(1002,item.type().toString(),tupleType.toString());
                    });
                }
            }

            const check = params.every( (item,index)=>{
                if( item.isAssignmentPattern || item.isRestElement || item.question ){
                    return true;
                }
                return !!args[index];
            });

            if( !check ){
                this.error(1000,params.length,args.length);
            }
        }
        if( !hasRest && this.arguments.length > length ){
            var ff = type.getConstructMethod();
            console.log("===========", ff )
            this.error(1000,params.length,this.arguments.length);
        }
        return true;
    }
    parser(){
        if( super.parser() === false )return false;
        this.callee.parser();
        this.callee.setRefBeUsed();
        this.arguments.forEach( item=>{
            item.parser();
            item.setRefBeUsed();
        });
        return true;
    }
}

module.exports = NewExpression;