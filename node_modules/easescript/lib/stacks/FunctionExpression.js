const Utils = require("../core/Utils");
const Declarator = require("./Declarator");
const FunctionScope = require("../scope/FunctionScope");
const Expression = require("./Expression");
const UnionType = require("../types/UnionType");
const FunctionType = require("../types/FunctionType");
const keySymbol = Symbol("key");
class FunctionExpression extends Expression{
    constructor(compilation,node,scope,parentNode,parentStack){
        scope = new FunctionScope(scope); 
        super(compilation,node,scope,parentNode,parentStack);
        if( parentStack && parentStack.isMethod){
            scope.isMethod=true;
            if( parentStack.isConstructor ){
                scope.isConstructor = true;
                this.isConstructor = true;
            }
        }
        this.isFunctionExpression=true;
        this.genericity = Utils.createStack(compilation,node.genericity,scope,node,this);
        this._returnType= Utils.createStack(compilation,node.returnType,scope,node,this);
        this.hasReturnType = !!node.returnType;
        let assignment = null;
        let hasRest = null;
        this.params = node.params.map( item=>{
            if( item.type =="Identifier" ){
                const stack = new Declarator(compilation,item,scope,node,this);
                if( assignment ){
                    assignment.error(1050,assignment.value()); 
                }
                scope.define(stack.value(), stack);
                return stack;
            }else{
                const stack = Utils.createStack(compilation,item,scope,node,this);
                if( stack.isRestElement ){
                    hasRest = stack;
                }
                assignment = stack;
                return stack;
            }
        });

        if( hasRest && this.params[ this.params.length-1 ] !== hasRest ){
            hasRest.error(1051,hasRest.value());
        }

        this.awaitCount = 0;
        this.async = scope.async =!!node.async;
        if( this.async ){
            scope.asyncParentScopeOf = scope;
        }
        if( !parentStack.isMethod ){
            this.callable = true;
        }
        this.body  = Utils.createStack(compilation,node.body,scope,node,this);
        this[keySymbol]={};
    }
    freeze(){
        super.freeze();
        super.freeze(this.params);
        this.genericity && this.genericity.freeze();
        this._returnType && this._returnType.freeze();
        this.body && this.body.freeze();
        this.params.forEach(stack=>stack.freeze());
    }
    definition(called, inference){
        const type = this.type(true).clone(inference).toString();
        const token = this.parentStack.isProperty || this.parentStack.isMethodDefinition ? this.parentStack.key : null;
        if( !token )return null;
        const identifier = token.value();
        const context = this;
        const params  = this.params.map( item=>{
            const name = item.value();
            const type = item.type(true).clone(inference);
            const rest = item.isRestElement ? '...' : '';
            if( item.question ){
                return `${rest}${name}?:${type.toString()}`
            }
            if( item.isAssignmentPattern && item.right ){
                const initial = item.right.value();
                return `${rest}${name}:${type.toString()}=${initial}`;
            }
            return `${rest}${name}:${type.toString()}`
        });
        return {
            kind:'method',
            comments:context.comments,
            identifier:identifier,
            expre:`(method) ${identifier}(${params.join(", ")}): ${type}`,
            location:token.getLocation(),
            file:this.compilation.file,
            context
        };
    }
    reference( called ){
        if( called ){
            return this.scope.returnItems[ this.scope.returnItems.length-1 ] || null;
        }
        return this;
    }
    referenceItems( called ){
        if( called ){
            let items = [];
            this.scope.returnItems.forEach( item=>{
                items = items.concat( item.referenceItems(called) );
            })
            return items;
        }else{
            return [this];
        }
    }
    description(){
        return this;
    }

    get returnType(){
        if( this._returnType  ){
            return this._returnType;
        }
        if( this[keySymbol]._loaded ){
            return this[keySymbol]._impsReturnType;
        }
        this[keySymbol]._loaded = true;
        this[keySymbol]._impsReturnType = null;
        if( this.parentStack.isCallExpression ){
            const declareDescription = this.parentStack.description();
            const declareParams =  declareDescription.params || [];
            const index = this.parentStack.arguments.indexOf( this );
            if( declareParams[ index ] ){
                const declareType = declareParams[ index ].type();
                if( declareType.isFunctionType ){
                    let returnType = declareType.returnType;
                    if( returnType ){
                        returnType =  returnType.type();
                        if( returnType.isGenericType ){
                            if( returnType.assignType ){
                                this.parentStack.getTypeByGeneric( returnType.assignType, true );
                            }
                            returnType = this.parentStack.getTypeByGeneric( returnType, true );
                        }
                        return this[keySymbol]._impsReturnType = returnType;
                    }
                }
            }
        }else if( this.parentStack.isMethodDefinition ){
            const name = this.parentStack.value();
            const kind = this.parentStack.isMethodGetterDefinition ? "get" : this.parentStack.isMethodSetterDefinition ? 'set' : null;
            const getImpModule=(imps)=>{
                if( !imps )return null;
                for( var impModule of imps){
                    if( impModule ){
                        const result = impModule.getMember(name, kind ) || getImpModule(impModule.implements) || getImpModule(impModule.extends);
                        if( result && result.returnType ){
                            return result;
                        }
                    }
                }
                return null;
            }
            const result = getImpModule(this.module.implements) || getImpModule(this.module.extends);
            if( result ){
                this[keySymbol]._impsReturnType = result.returnType;
            }
        }
        return this[keySymbol]._impsReturnType;
    }

    type( called ){
        if( !called ){
            return this.getFunType();
        }
        const rType = this.returnType;
        if( rType ){
            return rType.type();
        }
        if( this.scope.returnItems.length < 1 ){
            return this.getGlobalTypeById("void");
        }
        if( this[keySymbol]._type ){
            return this[keySymbol]._type;
        }
        const typeSet = new Set();
        this.scope.returnItems.forEach( item=>{
            const type = item.type();
            typeSet.add( type );
        });
        const items = Array.from( typeSet.values() );
        if( items.length ===1 ){
            return this[keySymbol]._type = items[0];
        }
        return this[keySymbol]._type=new UnionType( items );
    }

    getFunType(){
        return this[keySymbol]._funType || (this[keySymbol]._funType = new FunctionType(this.getGlobalTypeById("Function"), this));
    }

    checker(){
        if( super.checker() ){
            this.genericity && this.genericity.checker();
            this.params.forEach( item=>item.checker() );
            this._returnType && this._returnType.checker();
            this.body && this.body.checker();
            const isInterface = this.module && (this.module.isDeclaratorModule || this.module.isInterface);
            if( this.isConstructor && this.module && !isInterface){
                if( this.scope.returnItems.length > 0 ){
                    const last = this.scope.returnItems[ this.scope.returnItems.length-1 ]
                    last.error(1052);
                }
                if( this.module.extends[0] && this.scope.firstSuperIndex != 1){
                    (this.body.childrenStack[0]||this.key).error(1053);
                }
            }else if( this.async && this._returnType ){
                let acceptType = this._returnType.type();
                const promiseType = this.getGlobalTypeById("Promise");
                if( promiseType && !promiseType.is( acceptType ) ){
                    this._returnType.error(1055,promiseType.toString());
                }
            }
            return true;
        }
        return false;
    }

    parser(){
        if( super.parser() ){
            this.genericity && this.genericity.parser();
            this.params.forEach( item=>item.parser() );
            this._returnType && this._returnType.parser();
            this.body && this.body.parser();
            return true;
        }
        return false;
    }
}

module.exports = FunctionExpression;