const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const InstanceofType = require("../types/InstanceofType");
class MethodDefinition extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        super(compilation,node,scope,parentNode,parentStack);
        this.isMethodDefinition= true;
        this._metatypes = [];
        this._annotations = [];
        this.isMethod=true;
        this.static  = Utils.createStack(compilation,node.static,scope,node,this);
        this.key     = Utils.createStack(compilation,node.key,scope,node,this);
        const name = this.key.value();
        if( name ==="constructor" || name === this.module.id ){
            this.isConstructor = true;
            this.callable = false;
            if( node.genericity ){
                this.key.error(1062);
            }
        }else{
            this.callable = true;
        }
        this.expression = Utils.createStack(compilation,node.value,scope,node,this);
        this.modifier= Utils.createStack(compilation,node.modifier,scope,node,this);
        this.override = Utils.createStack(compilation,node.override,scope,node,this); 
        this.expression.key = this.key;
        this.scope = this.expression.scope;
        this.kind = node.kind;
        if( !this.static ){
            this.expression.scope.define("this", new InstanceofType(this.module,this) );
        }
        this.module.addMember(name, this);
        this.useRefItems = new Set();
    }

    addUseRef( stack ){
        this.useRefItems.add(stack);
    }

    freeze(){
        this.key.freeze();
        super.freeze();
        super.freeze( this.scope );
        super.freeze( this.static );
        super.freeze( this._metatypes );
        super.freeze( this._annotations );
        super.freeze( this.modifier );
        super.freeze( this.override );
        super.freeze( this._annotations );
        super.freeze( this.useRefItems );
        this.expression.freeze();
    }
    
    definition( called , inference ){
        const identifier = this.key.value();
        const context = this;
        const type = this.type(true).clone(inference).toString();
        const params  = this.params.map( item=>{
            const name = item.value();
            const type = item.type(true).clone(inference);
            const rest = item.isRestElement ? '...' : '';
            if( item.question ){
                return `${rest}${name}?:${type.toString()}`
            }
            if( item.isAssignmentPattern && item.right ){
                const initial = item.right.value();
                return `${rest}${name}:${type.toString()}=${initial}`;
            }
            return `${rest}${name}:${type.toString()}`
        });
        const modifier = this.modifier ? this.modifier.value() : "public";
        let owner = this.module.getName();
        const _static = this.static ? 'static ' : '';
        const declareGenerics = this.module.getModuleGenerics();
        if( declareGenerics && ( !_static || this.isConstructor ) ){
            owner = [owner,'<',declareGenerics.map( type=>type.clone(inference) ).join(", "),'>'].join("")
        }

        if( this.isConstructor ){
            return {
                kind:"constructor",
                comments:context.comments,
                identifier:identifier,
                expre:`constructor ${this.module.toString(true,inference)}(${params.join(", ")}): ${owner}`,
                location:this.key.getLocation(),
                file:this.compilation.file,
                context
            };
        }
        const generics = (this.genericity ? this.genericity.elements : []).map( item=>{
            const type = inference ? inference( item.type() ) : item.type();
            return type.toString(true);
        });
        const strGenerics = generics.length > 0 ? `<${generics.join(", ")}>` : '';
        return {
            kind:"method",
            comments:context.comments,
            identifier:identifier,
            expre:`(method) ${_static}${modifier} ${owner}.${identifier}${strGenerics}(${params.join(", ")}): ${type}`,
            location:this.key.getLocation(),
            file:this.compilation.file,
            context
        };
    }

    set metatypes(value){
        this._metatypes = value;
        if( this.isConstructor ){
            if( !this.callable ){
                this.callable = value.some( (metatype)=>{
                    return metatype.name.toLowerCase() === "callable";
                });
            }
            if( this.callable ){
                this.module.callable=this;
            }
        }
    }

    get metatypes(){
       return this._metatypes; 
    }

    set annotations(value){
        this._annotations = value;
        if( !this.override ){
            this.override = value.some( (annotation)=>{
                return annotation.name.toLowerCase() ==="override";
            });
        }
    }

    get annotations(){
        return this._annotations;
    }

    get params(){
        return this.expression.params;
    }

    get body(){
        return this.expression.body;
    }

    get genericity(){
        return this.expression.genericity;
    }
    reference(called){
        return this.expression.reference( called );
    }
    referenceItems(called){
        return this.expression.referenceItems( called );
    }
    description(){
        return this;
    }
    error(code,...args){
        this.key.error(code,...args)
    }
    warn(code,...args){
        this.key.warn(code,...args)
    }

    getFunType(){
        return this.expression.getFunType();
    }

    type( called ){
        const name = this.key.value();
        if( name ==="constructor" || name === this.module.id ){
            return this.module;
        }
        return this.expression.type( called );
    }

    get returnType(){
        return this.expression.returnType;
    }

    value(){
        return this.key.value(); 
    }

    checker(){
        if( super.checker() ){
            const metatypes = this.metatypes;
            const annotations = this.annotations;
            metatypes && metatypes.forEach( item=>item.checker() );
            annotations && annotations.forEach( item=>item.checker() );
            this.expression.checker();
            const kind = this.isAccessor ? 'accessor' : 'method';
            const parent = this.module.extends[0];
            if( this.override ){
                const pMethod = parent && parent.getMember( this.key.value() )
                if( !parent || !pMethod ){
                    this.key.error(1063,this.key.value(),kind)
                }
                if( this.params.length !== pMethod.params.length ){
                    if( this.isAccessor ){
                        this.key.error(1089,this.key.value() );
                    }else{
                        this.key.error(1088,this.key.value() );
                    }
                }
            }else if( parent ){
                const parentMethod = parent.getMember( this.key.value() );
                if( parentMethod && parentMethod.modifier.value() !=="private" ){
                    this.key.error(1064,this.key.value(),kind)
                }
            }
            return true;  
        }
        return false;
    }

    parser(){
        if( super.parser() ){
            const metatypes = this.metatypes;
            const annotations = this.annotations;
            metatypes && metatypes.forEach( item=>item.parser() );
            annotations && annotations.forEach( item=>item.parser() );
            this.expression.parser();
            return true;
        }
        return false;
    }
}

module.exports = MethodDefinition;