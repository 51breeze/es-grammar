const Stack = require("../core/Stack");
const Utils = require("../core/Utils");
const ClassScope = require("../scope/ClassScope");
class InterfaceDeclaration extends Stack{
    constructor(compilation,node,scope,parentNode,parentStack){
        scope = new ClassScope(scope);
        super(compilation,node,scope,parentNode,parentStack);
        this.isInterfaceDeclaration= true;
        this.id          = Utils.createStack(compilation,node.id,scope,node,this);
        const module =this.module=compilation.createModule(this.namespace, this.id.value());
        this.id.module = module;
        this.inherit     = Utils.createStack(compilation,node.extends,scope,node,this);
        if( node.extends && node.extends.genericity ){
            this.inherit.assignGenerics = node.extends.genericity.map( item=>Utils.createStack(compilation,item,scope,node,this) );
        }
        this.implements  = (node.implements || []).map((item)=>{
            const stack = Utils.createStack(compilation,item,scope,node,this);
            if( item.genericity ){
                stack.assignGenerics = item.genericity.map( item=>Utils.createStack(compilation,item,scope,node,this) );
            }
            return stack;
        });
        this.imports     =[];
        this.modifier = Utils.createStack(compilation,node.modifier,scope,node);
        this.genericity  = Utils.createStack(compilation,node.genericity,scope,node,this);
        module.comments   = this.comments;
        module.isInterface = true;
        compilation.addModuleStack(module,this);
    }
    freeze(){
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        (this.body||[]).forEach(stack=>stack.freeze());
    }
    definition(){
        const kind = "Interface";
        return {
            kind:"Module",
            comments:this.comments,
            identifier:this.id.value(),
            expre:`(${kind}) ${this.module.getName()}`,
            location:this.id.getLocation(),
            file:this.file,
            context:this
        };
    }
    createCompleted(){
        const compilation = this.compilation;
        this.imports.forEach( stack=>{
            const module = compilation.getModuleById( stack.value() );
            if( module && module.isModule ){
                if( this.checkDepend(this.module,module) ){
                    stack.error(1024,stack.value())
                }
                const nameId = stack.alias ? stack.alias.value() :  module.id;
                if( !this.module.addImport(nameId, module, module.id != nameId ) ){
                    stack.error(1025,nameId)
                } 
            }else{
                stack.error(1026,stack.value())
            }
        });
        if( this.inherit ){
            const module = this.getModuleById( this.inherit.value() );
            if( module ){
                module.used = true;
                this.module.extends = module;
                this.compilation.addDependency(module,this.module );
            }else{
                this.inherit.error(1027,this.inherit.value());
            }
        }
        this.module.implements = this.implements.map( (stack)=>{
            const module = this.getModuleById( stack.value() );
            if( module ){
                if( !(module.isInterface || module.isDeclarator) ){
                    stack.error(1028,stack.value()) 
                }
                this.compilation.addDependency(module,this.module );
            }else {
                stack.error(1029,stack.value());
            }
            return module;
        });
        const metatypes = [];
        const annotations = [];
        this.body = this.node.body.map( item=>{
            const stack = Utils.createStack( compilation, item, this.scope, this.node,this );
            if( stack.isMetatypeDeclaration ){
                metatypes.push( stack );
            }else if( stack.isAnnotationDeclaration ){
                annotations.push( stack );
            }else{
                stack.metatypes = metatypes.splice(0,metatypes.length);
                stack.annotations = annotations.splice(0,annotations.length);
                return stack;
            }
        }).filter( item=>!!item );
    }
    genericsCheck(typeModule, assignGenerics){
        const stackModule = this.compilation.getStackByModule( typeModule );
        if( stackModule ){
            assignGenerics = assignGenerics || [];
            const declareGenerics = stackModule.genericity ? stackModule.genericity.elements : [];
            const requires = declareGenerics.filter( item=>!item.isGenericTypeAssignmentDeclaration );
            const lastStack = assignGenerics[ assignGenerics.length-1 ] || this.inherit;
            if( requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length ){
                if( requires.length === declareGenerics.length ){
                    lastStack.error(1030,typeModule.toString(),requires.length);
                }else{
                    lastStack.error(1031,typeModule.toString(),requires.length,declareGenerics.length);
                }
            }
            if( declareGenerics.length > 0 ){
                assignGenerics.forEach( (item,index)=>{
                    const declareType = declareGenerics[index] && declareGenerics[index].type();
                    if( declareType && declareType.hasConstraint && !declareType.check(item) ){  
                        item.error(1003,item.type().toString(),declareType.toString());
                    }
                });
            }
        }
    }
    parser(){
        if( this.genericity ){
            this.genericity.parser();
        }
        if( this.inherit ){
            this.genericsCheck( this.module.extends[0], this.inherit.assignGenerics);
        }
        this.module.implements.forEach( (impModule,index)=>{
            this.genericsCheck( impModule, this.implements[index].assignGenerics);
        });
        this.body.forEach( item=>item.parser() );
    }
    checker(){
        this.body.forEach( item=>item.checker() );
    }
    value(){
        return this.id.value();
    }
    raw(){
        return this.node.name;
    }
}

module.exports = InterfaceDeclaration;