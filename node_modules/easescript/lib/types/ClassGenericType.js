const Utils = require("../core/Utils");
const Type = require("./Type");
class ClassGenericType extends Type{
    constructor(types, inherit, isClass, target ){
        super('$ClassGenericType', inherit );
        this.isClassGenericType=true;
        this.isClassType = !!isClass;
        this.types = types;
        this.target = target;
        this.isThisType = !!(target && target.isThisType);
        this.hasGeneric = types.some(type=>{
            return type && !!(type.isGenericType || type.hasGeneric);
        });
    }
    clone(inference){
        if( !this.hasGeneric || !inference){
            return this;
        }
        const types = this.types.map( type=>inference(type) );
        return new ClassGenericType(types, this.extends[0], this.isClassType, this.target);
    }
    is( type ){
        if( !type || !(type instanceof Type) )return false;
        if( type.isGenericValueType ){
            type = type.value;
            if( !type ){
                return true;
            }
        }
        if( type === this || type.isNullableType || type.isAnyType )return true;
        if( type.target === this.target && type.isClassGenericType )return true;
        if(this.isClassType && (type.isInstanceofType || Utils.isWrapType(type) || type.isInterface)){
            return false;
        }
        let baseType = type;
        if(type.isClassGenericType){
            baseType = type.isClassType ? type.types[0] : type.extends[0];
        }else if( type.isInstanceofType ){
            baseType = type.extends[0];
            if( !(type.target && type.target.isNewExpression) || !this.extends[0].is(baseType) ){
                return false;
            }
            const declares = Utils.isClassType(baseType) && baseType.getModuleGenerics() || [];
            const genericTypes = type.target.getGenericTypes();
            return this.types.every( (item,index)=>{
                const declareType  = declares[index];
                if( declareType ){
                    const genericType = genericTypes.get( declares[index] );
                    if( genericType ){
                        return item.is(genericType);
                    }
                }else if( declareType.assignType ){
                    return item.is(declareType.assignType);
                }
                return true;
            });
        }
        if( this.isClassType ){
            const isMoudle = baseType.isModule && !Utils.isWrapType(baseType);
            if( this.types[0].isAnyType ){
                return isMoudle || this.types[0]===baseType;
            }
            return isMoudle && this.types[0].is(baseType);
        }else if(this.extends[0] === baseType){
            if( type.isClassGenericType ){
                return this.types.every( (item,index)=>item===type.types[index] );
            }else{
                return true;
            }
        }
        return false;
    }
    toString( flag ){
        const types = this.types.map( type=>type.toString(flag) );
        if( this.target ){
            return `${this.target.value()}<${types.join(",")}>`;
        }
        return this.extends[0].toString();
    }

}
module.exports = ClassGenericType;