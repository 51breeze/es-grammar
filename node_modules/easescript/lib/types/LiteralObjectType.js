const Type = require("./Type");
class LiteralObjectType extends Type{
    constructor(inherit,target,properties=null){
        super("$LiteralObjectType",inherit)
        this.target = target;
        this.isLiteralObjectType = true;
        this.properties = properties || target.attributes;
        this.hasGeneric = target.isTypeObjectDefinition ? Array.from(this.properties).some(item=>{
            const [key,value] = item; 
            const type =  value.type();
            return !!(type.isGenericType || type.hasGeneric);
        }) : false;
    }
    clone(inference){
        if( !this.hasGeneric || !inference ){
            return this;
        }
        const properties = new Map();
        this.properties.forEach( (item,key)=>{
            const type = inference( item.type() );
            properties.set(key,type);
        });
        return new LiteralObjectType(this.inherit, this.target, properties);
    }
    attribute( property ){
        return this.properties.get(property);
    }
    check( stack ){
        return this.constraint( stack.type() );
    }
    constraint( type ){
        if( !type || !(type instanceof Type) )return false;
        if( type.isGenericValueType ){
            type = type.value;
        }
        if( type === this || type.isLiteralObjectType && type.target === this.target )return true;
        if( (type.isLiteralObjectType || (type.isGenericType && type.hasConstraint)) && this.is(type) ){
            return Array.from(this.properties).every( item=>{
                const [name,base] = item;
                const right = type.attribute( name );
                if( !right ){
                    const origin = this.target.attribute(name);
                    return !!origin.question;
                }
                return base.type().check(right);
            });
        }
        return false;
    }
    is( type ){
        if( !type || !(type instanceof Type) )return false;
        if( type.isGenericValueType ){
            type = type.value;
            if( !type ){
                return true;
            }
        }
        if( type === this || type.isNullableType || type.isAnyType )return true;
        if( type.isLiteralObjectType && type.target === this.target )return true;
        return this.inherit.is( type.isLiteralObjectType ? type.inherit : type );
    }
    toString(){
        const properties = Array.from(this.properties).map( item=>{
            const [name,base] = item;
            const type = base.type();
            const origin = this.target.attribute(name);
            if( origin && origin.computed ){
                return `[${name}]: ` + type.toString();
            }
            const question = origin.question ? '?' : '';
            return `${name}${question}: ` + type.toString();
        });
        return `{${properties.join(',')}}`;
    }
}
module.exports = LiteralObjectType;