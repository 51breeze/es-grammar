const Type = require("./Type");
class TupleType extends Type{
    constructor(inherit, elements , target, rest = false , isTupleUnion=false){
        super("$TupleType",inherit);
        this.elements = [].concat(elements);
        const len = this.elements.length;
        this.rest = rest;
        this.requireCount = rest && len > 1 ? len-1 : len;
        this.isTupleType = true;
        this.prefix = !!target.prefix;
        this.isTupleUnion = isTupleUnion ? true : !!target.isTypeTupleUnionDefinition;
        this.target = target;
        this.hasGeneric = this.elements.some(item=>{
            const type =  item.type();
            return type && !!(type.isGenericType || type.hasGeneric);
        });
    }
    attribute(index){
        if( !(this.prefix || this.isTupleUnion) ){
            return this.elements[ index ] || null;
        }
        return null;
    }
    clone(inference){
        if( !this.hasGeneric || !inference ){
            return this;
        }
        const elements = this.elements.map( item=>{
            return inference(item.type());
        });
        if( elements.length === 1 && elements[0].isTupleType ){
            return elements[0];
        }
        return new TupleType(this.inherit,elements,this.target,this.rest);
    }
    checkItems(items, errorItems=[]){
        const checkItem = (base, item)=>{
            const type = item.type();
            if( ( base.isThisType || (base.target && base.target.isThisType) ) && !type.isInstanceofType ){
                errorItems.push( item );
                return false;
            }
            if( !base.type().is( type ) ){
                errorItems.push( item );
                return false;
            }
            return true;
        }
        if(this.prefix || this.rest || this.isTupleUnion){
            return items.every( (item)=>{
                return this.elements.some( base=>{
                    return checkItem(base, item);
                });
            });
        }
        const len = this.elements.length;
        const rest = len > 0 ? this.elements[ len-1 ] : null;
        const hasRest = rest && rest.type().rest;
        const requireCount = hasRest ? this.requireCount-1 : this.requireCount;
        if( (hasRest && items.length < requireCount) ){
            return false;
        }else if( !hasRest && items.length !== requireCount ){
            return false;
        }
        return items.every( (item,index)=>{
            let base = this.elements[index];
            if( base && !(hasRest && base === rest) ){
                return checkItem(base,item);
            }else{
                if( hasRest && rest ){
                    return checkItem(rest,item);
                }else{
                    return this.elements.some( (base)=>{
                        return checkItem(base,item);
                    });
                }
            }
        });
    }
    is( type ){
        if( !type || !(type instanceof Type) )return false;
        if( type.isGenericValueType ){
            type = type.value;
            if( !type ){
                return true;
            }
        }
        if( type === this || type.isNullableType || type.isAnyType )return true;
        if( this.isTupleUnion && !this.inherit.is(type.inherit) ){
            return false;
        }
        let items = [];
        if( type.isTupleType || type.isLiteralArrayType){
            items =type.elements;
        }else if( type.isLiteralObjectType){
            items=[type.inherit];
        }else if( type.isClassGenericType && type.inherit === this.inherit ){
            items = type.types;
        }else{
            items=[type];
        }
        return this.checkItems( items );
    }
    toString(){
        if( this.elements.length === 1){
            let base = this.elements[0].type();
            base = (base.isGenericValueType ? base.value : base) || base;
            if( base.isUnionType && base.target && base.target.isLiteralArrayType){
                return `(${base.toString()})[]`;
            }
        }
        const elements = this.elements.map( (item)=>{
            return item.type().toString();
        });
        const rest = this.rest && !this.target.isRestElement ? '...' : '';
        if( this.isTupleUnion ){
            return `(${elements.join(" | ")})[]`;
        }
        if( elements.length === 1 && (this.prefix||this.rest) ){
            return `${rest}${elements[0]}[]`;
        }
        return `${rest}[${elements.join(',')}]`;
    }
}
module.exports = TupleType;