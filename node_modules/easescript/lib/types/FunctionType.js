const Type = require("./Type.js");
class FunctionType extends Type{
    constructor(inherit,target, params, returnType){
        super("$FunctionType",[inherit]);
        this.params = params ? params : target.params || [];
        this._returnType = returnType;
        this.isFunctionType = true;
        this.target = target;
    }
    get returnType(){
        if( this._returnType ){
            return this._returnType;
        }
        return this.target.type(true);
    }
    type(called){
        return called ? this.returnType : this;
    }

    checkHasGeneric(){
        if( this.hasGeneric === void 0){
            this.hasGeneric = this.params.concat( this.returnType ).some( item=>{
                const type = item && item.type();
                if( type ){
                    if( type.isFunctionType ){
                        type.checkHasGeneric()
                    }
                    return !!(type.isGenericType || type.hasGeneric);
                }
            });
        }
        return this.hasGeneric;
    }

    clone(inference){
        if( !inference || !this.checkHasGeneric() ){
            return this;
        }
        const params = this.params.map( item=>{
            return item.type().clone(inference);
        });
        let returnType = this.returnType;
        if( returnType ){
            returnType = returnType.type().clone(inference);
        }
        return new FunctionType(this.inherit,this.target,params,returnType);
    }
    is(type){
        if( !type || !(type instanceof Type) || !(type.isFunctionType) )return false;
        if( type.isGenericValueType ){
            type = type.value;
            if( !type ){
                return true;
            }
        }
        if( type === this || type.target === this.target || type.isNullableType || type.isAnyType )return true;

        if( type.params.length > 0 ){
            if( this.params.length < type.params.length){
                return false;
            }
            const result = type.params.every( (item,index)=>{
                const acceptType = this.params[index] && this.params[index].type();
                return acceptType && acceptType.is( item.type() );
            });
            if( !result ){
                return false;
            }
        }

        const leftType   = this.returnType;
        const rightType   = type.returnType;
        if( leftType ){
            return leftType.is( rightType );
        }
        return true;
    }

    toString(){
        const target = this.target;
        const params = this.target.params.map( (item,index)=>{
            const type = this.params[index].type();
            if( item.isAssignmentPattern && item.right ){
                const initial = item.right.value();
                return `${item.value()}:${type.toString()}=${initial}`;
            }
            if( item.isRestElement){
                return `...${item.value()}:${type.toString()}`;
            }
            if( item.question ){
                return `${item.value()}?:${type.toString()}`;
            }
            return `${item.value()}:${type.toString()}`;
        });
        const returnType = this.returnType;
        const genericity = target.genericity ? '<'+(target.genericity.elements.map( item=>item.type().toString(true) )).join(', ')+'>' : '';
        return `${genericity}(${params.join(", ")})=>${returnType.toString()}`;
    }
}
module.exports = FunctionType;